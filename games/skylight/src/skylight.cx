package main

import "app"
import "args"
import "fps"
import "gam"
import "gfx"
import "gui"
import "m44"
import "mat"
import "phx"
import "q4"
import "snd"
import "time"
import "v1"
import "v2"
import "v3"
import "v4"

// TODO : can't navigate with keyboard at startup
// TODO : dialog disapear if exit button is pushed with keyboard

type Sky struct {
    name str
    loaded bool
    diffuse gfx.TextureId
    specular gfx.TextureId
}

type Level struct {
    gfxName str
    gfxOctree gfx.OctreeId
    phxName str
    phxOctree gfx.OctreeId
    loaded bool
    physic i32
    debug i32
}

// Types
type Anim struct {
	model gfx.ModelId
	anim gfx.AnimationId
}

type Player struct {
    name str
    spineName str
    torsoName str
    shoulderName str
    handName str
    loaded bool
    visible bool

    color mat.v4
	idle Anim
	throw Anim
	jump Anim
	forward Anim
	backward Anim
	left Anim
	right Anim

	spine i32
	torso i32
	shoulder i32
	hand i32

	backwardState bool
	jumpingState bool

	phxObject i32
	backwardQuat mat.v4

	yawTime f32

	offset mat.v3
	position mat.v3
	velocity mat.v3
	rotation mat.v4
	camera mat.v3
	at mat.v3
	ri mat.v3

	xdir f32
	ydir f32
	zdir f32
	scale f32
	world m44
	handTransform m44

	cpuFire f32

	tmpAnim0 gfx.AnimationId
	tmpAnim1 gfx.AnimationId
	tmpAnim2 gfx.AnimationId
	switchAnimTime f32
	currentAnim gfx.AnimationId
	runtimeAnim gfx.AnimationId
	previousAnim gfx.AnimationId

	weapon i32
	weaponPos mat.v3
	weaponAt mat.v3
	aimPosition mat.v3
	fireWeapon i32
	fireAnimTime f32
	fireAnimLength f32
	fireAnimThresh f32
	fireAnimThrow f32

	oldPhxPosition mat.v3
	oldVoidCount i32
}

// Globals ...
var prfGameOnRender fps.ProfileId = fps.InvalidProfile()
var prfClear fps.ProfileId = fps.InvalidProfile()
var prfRenderSky fps.ProfileId = fps.InvalidProfile()
var prfRenderGround fps.ProfileId = fps.InvalidProfile()
var prfPhxRender fps.ProfileId = fps.InvalidProfile()
var prfRenderPlayers fps.ProfileId = fps.InvalidProfile()
var prfRenderWeapons fps.ProfileId = fps.InvalidProfile()
var prfUpdatePlayers fps.ProfileId = fps.InvalidProfile()
var prfRenderSkyminers fps.ProfileId = fps.InvalidProfile()
var prfRenderSkynotes fps.ProfileId = fps.InvalidProfile()
var prfPhxUpdate fps.ProfileId = fps.InvalidProfile()
var prfGameOnUpdate fps.ProfileId = fps.InvalidProfile()
var prfUpdateWeapons fps.ProfileId = fps.InvalidProfile()
var prfModelUpdate fps.ProfileId = fps.InvalidProfile()
var prf14 fps.ProfileId = fps.InvalidProfile()
var prfUpdateAnimations fps.ProfileId = fps.InvalidProfile()
var prfUpdatePositions fps.ProfileId = fps.InvalidProfile()
var prfCameraUpdate fps.ProfileId = fps.InvalidProfile()
var prfPhxEmit fps.ProfileId = fps.InvalidProfile()
var prfPhxRemove fps.ProfileId = fps.InvalidProfile()
var prfParticleUpdate fps.ProfileId = fps.InvalidProfile()
var prfAlphaFull fps.ProfileId = fps.InvalidProfile()
var prfAlphaHalf fps.ProfileId = fps.InvalidProfile()

var characters []Player
var players []Player
var skies []Sky
var levels []Level

var debugFrustum bool = false
var debugSky bool = false
var currentSky i32
var currentLevel i32

var skyminerModel gfx.ModelId = gfx.ModelInvalid()
var skyminerScale f32 = 0.1

var aimMax i32 = 0
var aimCount i32 = 0

var opaqueTarget gfx.TargetId
var alphaTarget gfx.TargetId
var alphaFullTarget gfx.TargetId
var mergeTarget gfx.TargetId
var edgeTarget gfx.TargetId

var groundMesh gfx.MeshId = gfx.InvalidMesh()
var texture gfx.TextureId = gfx.InvalidTexture()
var dollar gfx.TextureId = gfx.InvalidTexture()
var smokeTexture gfx.TextureId = gfx.InvalidTexture()

var dollarMesh gfx.MeshId = gfx.InvalidMesh()

var skyWorld mat.m44 = m44.IDENTITY
var skyMesh gfx.MeshId = gfx.InvalidMesh()
var brdf gfx.TextureId = gfx.InvalidTexture()

var camera gam.CameraId
var frustum gfx.FrustumId

var worldPosY f32 = -10.0

var worldSizeX f32 = 2000.0
var worldSizeZ f32 = 2000.0

var worldCellX i32 = 64
var worldCellZ i32 = 64

var phxGround0 i32
var phxGround1 i32

var groundScale f32 = 2.0
var groundRight f32 = worldSizeX / groundScale
var groundBack f32 = worldSizeZ / groundScale
var groundWidth i32 = 16
var groundHeight i32 = 16

var GAME_MODE_MENU       i32 = 1
var GAME_MODE_GAME       i32 = 2
var GAME_MODE_LIGHT      i32 = 4
var GAME_MODE_DEBUG      i32 = 8
var GAME_MODE_VIDEO      i32 = 16

var gameMode i32
var gameModeMatch bool = false
var gameModeNames []str
var gameModeValues []i32
var hasModeMenu bool = false
var hasModeGame bool = false
var isModeLight bool = false
var isModeDebug bool = false
var isModeVideo bool = false

var TAG_GROUND i32 = 1
var TAG_PLAYER i32 = 2
var TAG_MINER i32 = 3
var TAG_DOLLAR i32 = 4
var TAG_AIM i32 = 5
var TAG_LEVEL i32 = 6

var CAMERA_FREE i32 = 0
var CAMERA_TPS i32 = 1
var CAMERA_FPS i32 = 2
var CAMERA_COUNT i32 = 3
var currentCamera i32 = CAMERA_TPS

var phxRemoveList []i32
var phxSortedList []i32

var WEAPON_SKYMINER i32 = 0
var WEAPON_SKYNOTE i32 = 1
var WEAPON_COUNT i32 = 2

var MOVE_ i32 = 0
var MOVE_TX i32 = 0
var MOVE_TY i32 = 1
var MOVE_TZ i32 = 2
var MOVE_R i32 = 3
var MOVE_COUNT i32 = 4
var ffx f32
var ffy f32
var ffz f32
var ffr f32
var ffs f32 = 0.01

var currentPlayer i32
var playerCount i32 = 3
var currentCPU i32 = 1
var currentCPU2 i32 = 2

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnEvent(controlIndex i32, controlAction i32) {
	var key i32 = gui.CurrentEvent.keyboard.key
	var action i32 = gui.CurrentEvent.keyboard.action
	var mods i32 = gui.CurrentEvent.keyboard.mods

	if mods == app.MOD_CTRL {
		if action == app.KEY_PRESS {
			if key == app.KEYCODE_LEFT {
				if action == app.KEY_PRESS {
					currentPlayer = currentPlayer - 1
					if currentPlayer < 0 {
						currentPlayer = len(players) - 1
					}
					currentCPU = (currentPlayer + 1) % len(players)
					currentCPU2 = (currentPlayer + 2) % len(players)
				}
			} else if key == app.KEYCODE_RIGHT {
				if action == app.KEY_PRESS {
					currentPlayer = currentPlayer + 1
					if currentPlayer >= len(players) {
						currentPlayer = 0
					}
					currentCPU = (currentPlayer + 1) % len(players)
					currentCPU2 = (currentPlayer + 2) % len(players)
				}
			} else if key == app.KEYCODE_UP {
				MOVE_ = MOVE_ + 1
				MOVE_ = MOVE_ % MOVE_COUNT
				if MOVE_ == MOVE_TX {
					printf("-----------TRANSLATE XXX\n")
				} else if MOVE_ == MOVE_TY {
					printf("-----------TRANSLATE YYY\n")
				} else if MOVE_ == MOVE_TZ {
					printf("-----------TRANSLATE ZZZ\n")
				} else if MOVE_ == MOVE_R {
					printf("-----------ROTATE\n")
				}
			} else if key == app.KEYCODE_DOWN {
				MOVE_ = MOVE_ - 1
				if MOVE_ < 0 {
					MOVE_ = MOVE_COUNT
				}
				if MOVE_ == MOVE_TX {
					printf("-----------TRANSLATE XXX\n")
				} else if MOVE_ == MOVE_TY {
					printf("-----------TRANSLATE YYY\n")
				} else if MOVE_ == MOVE_TZ {
					printf("-----------TRANSLATE ZZZ\n")
				} else if MOVE_ == MOVE_R {
					printf("-----------ROTATE\n")
				}
			}
        }
	} else if mods == app.MOD_ALT && isModeDebug {
		if action == app.KEY_PRESS {
			if key == app.KEYCODE_LEFT {
				if action == app.KEY_PRESS {
					currentSky = currentSky - 1
					if currentSky < 0 {
						currentSky = len(skies) - 1
					}
				}
			} else if key == app.KEYCODE_RIGHT {
				if action == app.KEY_PRESS {
					currentSky = currentSky + 1
					if currentSky >= len(skies) {
						currentSky = 0
					}
				}
			} else if key == app.KEYCODE_UP {
                if action == app.KEY_PRESS {
                    debugSky = debugSky == false
                }
			} else if key == app.KEYCODE_DOWN {
                if action == app.KEY_PRESS {
                    debugSky = debugSky == false
                }
			}
		}
	} else if mods == app.MOD_SHIFT {
		if action == app.KEY_PRESS {
			if key == app.KEYCODE_LEFT {
				if action == app.KEY_PRESS {
					currentCamera = currentCamera - 1
					if currentCamera < 0 {
						currentCamera = CAMERA_COUNT - 1
					}
				}
			} else if key == app.KEYCODE_RIGHT {
				if action == app.KEY_PRESS {
					currentCamera = currentCamera + 1
					if currentCamera >= CAMERA_COUNT {
						currentCamera = 0
					}
				}
			}
		}

		if key == app.KEYCODE_UP && action != app.KEY_RELEASE{
			if MOVE_ == MOVE_TX {
				ffx = ffx + ffs * 20.0
			} else if MOVE_ == MOVE_TY {
				ffy = ffy + ffs
			} else if MOVE_ == MOVE_TZ {
				ffz = ffz + ffs
			} else if MOVE_ == MOVE_R {
				ffr = ffr + ffs
			}
			printf("tx %f, ty %f, tz %f, r %f\n", ffx, ffy, ffz, ffr)
		} else if key == app.KEYCODE_DOWN && action != app.KEY_RELEASE{
			if MOVE_ == MOVE_TX {
				ffx = ffx - ffs * 20.0
			} else if MOVE_ == MOVE_TY {
				ffy = ffy - ffs
			} else if MOVE_ == MOVE_TZ {
				ffz = ffz - ffs
			} else if MOVE_ == MOVE_R {
				ffr = ffr - ffs
			}
			printf("tx %f, ty %f, tz %f, r %f\n", ffx, ffy, ffz, ffr)
		}
	} else if mods == app.MOD_NONE {
   		if key == app.KEYCODE_LEFT || key == app.KEYCODE_A {
			if action == app.KEY_PRESS {
				players[currentPlayer].switchAnimTime = -1.0
				players[currentPlayer].previousAnim = players[currentPlayer].currentAnim
				players[currentPlayer].zdir = -1.0
			} else if action == app.KEY_RELEASE {
				players[currentPlayer].switchAnimTime = -1.0
				players[currentPlayer].previousAnim = players[currentPlayer].currentAnim
				if players[currentPlayer].zdir == -1.0 {
					players[currentPlayer].zdir = 0.0
				}
			}
		} else if key == app.KEYCODE_RIGHT || key == app.KEYCODE_D {
			if action == app.KEY_PRESS {
				players[currentPlayer].switchAnimTime = -1.0
				players[currentPlayer].previousAnim = players[currentPlayer].currentAnim
				players[currentPlayer].zdir = 1.0
			} else if action == app.KEY_RELEASE {
				players[currentPlayer].switchAnimTime = -1.0
				players[currentPlayer].previousAnim = players[currentPlayer].currentAnim
				if players[currentPlayer].zdir == 1.0 {
					players[currentPlayer].zdir = 0.0
				}
			}
		} else if key == app.KEYCODE_UP || key == app.KEYCODE_W {
			if action == app.KEY_PRESS {
				players[currentPlayer].switchAnimTime = -1.0
				players[currentPlayer].previousAnim = players[currentPlayer].currentAnim
				players[currentPlayer].xdir = -1.0
			} else if action == app.KEY_RELEASE {
				players[currentPlayer].switchAnimTime = -1.0
				players[currentPlayer].previousAnim = players[currentPlayer].currentAnim
				if players[currentPlayer].xdir == -1.0 {
					players[currentPlayer].xdir = 0.0
				}
			}
		} else if key == app.KEYCODE_DOWN || key == app.KEYCODE_S {
			if action == app.KEY_PRESS {
				players[currentPlayer].switchAnimTime = -1.0
				players[currentPlayer].previousAnim = players[currentPlayer].currentAnim
				players[currentPlayer].xdir = 1.0
			} else if action == app.KEY_RELEASE {
				players[currentPlayer].switchAnimTime = -1.0
				players[currentPlayer].previousAnim = players[currentPlayer].currentAnim
				if players[currentPlayer].xdir == 1.0 {
					players[currentPlayer].xdir = 0.0
				}
			}
		} else if key == app.KEYCODE_SPACE {
			if action == app.KEY_PRESS {
				if players[currentPlayer].weapon == WEAPON_SKYNOTE {
					players[currentPlayer].fireWeapon = 1
				} else if players[currentPlayer].weapon == WEAPON_SKYMINER {
					players[currentPlayer].fireWeapon = 1
				}
			} else if action == app.KEY_RELEASE {
				//fireWeapon = 0
			}
		} else if key == app.KEYCODE_V {
			if action == app.KEY_PRESS {
				players[currentPlayer].ydir = 1.0
				players[currentPlayer].jumpingState = true
			} else if action == app.KEY_REPEAT {
				players[currentPlayer].ydir = 1.0
				players[currentPlayer].jumpingState = true
			} else if action == app.KEY_RELEASE {
				players[currentPlayer].ydir = 0.0
				players[currentPlayer].jumpingState = false
			}
		} else if key == app.KEYCODE_1 {
			if action == app.KEY_PRESS {
				players[currentPlayer].weapon = WEAPON_SKYMINER
			}
		} else if key == app.KEYCODE_2 {
			if action == app.KEY_PRESS {
				players[currentPlayer].weapon = WEAPON_SKYNOTE
			}
		} else if key == app.KEYCODE_9 {
            if action == app.KEY_PRESS {
                debugFrustum = debugFrustum == false
            }
        } else if key == app.KEYCODE_7 {
            if action == app.KEY_PRESS {
                var phxPlayer i32 = players[0].phxObject
                phx.SetObjectPosition(phxPlayer, v3.make(-786.0, 3000.0, -409.0))
            }
        }
	}

	var mouseAction i32 = gui.CurrentEvent.mouse.action
	var mouseButton i32 = gui.CurrentEvent.mouse.button
	if mouseAction == app.MOUSE_PRESS && mouseButton == app.BUTTON_LEFT {
	}

	if mouseAction == app.MOUSE_MOVE {
	var mousePosition mat.v2 = gui.CurrentEvent.mouse.position
		players[currentPlayer].aimPosition = v3.make(2.0 * mousePosition.x / gfx.gfx_width - 1.0, 2.0 * mousePosition.y / gfx.gfx_height - 1.0, 0.0)
	}

	if currentCamera == CAMERA_FREE {
		gam.FreeCameraProcess(camera, &gui.CurrentEvent)
	} else if currentCamera == CAMERA_FPS {
		gam.FpsCameraProcess(camera, &gui.CurrentEvent)
	} else if currentCamera == CAMERA_TPS {
		gam.TpsCameraProcess(camera, &gui.CurrentEvent)
	}
}

func newAimBox(position mat.v3) {
	var axis mat.v3 = v3.normalize(v3.rand())
	var radius f32 = 2.5
	var right mat.v3 = v3.make(radius, 0.0, 0.0)
	var top mat.v3 = v3.make(0.0, radius, 0.0)
	var back mat.v3 = v3.make(0.0, 0.0, radius)

	var miner i32 = phx.AddObject(phx.TYPE_BOX, TAG_AIM, -1,
		phx.STATE_TRANSLATE /*| phx.STATE_DEBUG*/, position, v3.make(0.0, f32.rand() * 10.0, 0.0), v3.ZERO,
		right, top, back, 1.0, 0.01, v4.make(0.0, 1.0, 0.0, 0.0),
		v4.make(f32.rand(), f32.rand(), f32.rand(), 1.0))
}


func fireSkyminer(position mat.v3, direction mat.v3, playerIndex i32) {
	var axis mat.v3 = v3.normalize(v3.rand())

	var mass f32 = 5.0
	var force f32 = 200.0

	var radius mat.v3 = v3.mulf(v3.sub(gfx.ModelGetMax(skyminerModel), gfx.ModelGetMin(skyminerModel)), skyminerScale * 0.1)
	var right mat.v3
	right.x = radius.x

	var top mat.v3
	top.y = radius.y

	var back mat.v3
	back.z = radius.z

	var acceleration mat.v3 = v3.mulf(direction, force / mass)

	var miner i32 = phx.AddObject(phx.TYPE_ELLIPSE, TAG_MINER, playerIndex,
		phx.STATE_TRANSLATE | phx.STATE_ROTATE/* | phx.STATE_DEBUG*/, position, acceleration, v3.ZERO,
		right, top, back, mass, 0.96, v4.make(axis.x, axis.y, axis.z, f32.rand() * 10.0), v4.ONE)
            phx.SetObjectMaxVelocity(miner, v3.make(4000.0, 4000.0, 4000.0))
            phx.SetObjectMaxAcceleration(miner, v3.make(1500.0, 1.0, 1500.0))
    phx.SetObjectAirFriction(miner, 0.3)
}


func emitSmoke(aimPosition mat.v3, normal mat.v3, player i32) {
	var emitter gfx.EmitterId = gfx.ParticleGetEmitter(256)
	gfx.EmitterSetPosition(emitter, aimPosition, v3.makef(3.0))
	gfx.EmitterSetVelocity(emitter, v3.makef(6.0), 0.5)
	gfx.EmitterSetScale(emitter, v3.makef(10.0), v3.makef(3.0))
	gfx.EmitterSetScaleVelocity(emitter, v3.makef(1.0), 0.3)
	gfx.EmitterSetOrientation(emitter, v4.ZERO, v4.make_v31(v3.ONE, v1.PI))
	gfx.EmitterSetAngularVelocity(emitter, v4.make(0.0, 0.0, 0.0, 0.3), v4.make_v31(v3.ZERO, 0.6))
	gfx.EmitterSetLife(emitter, 7.0, 1.0)
	gfx.EmitterSetPuff(emitter, 1, 0)
	gfx.EmitterSetColor(emitter, v4.mul(players[player].color, v4.make(1.0, 1.0, 1.0, 0.1)), v4.makef(0.1))
	gfx.EmitterSetTexture(emitter, smokeTexture)
	gfx.EmitterInit(emitter, 256, 10.0, 0.2, 0.2)
}


func fireSkynotes(position mat.v3, direction mat.v3, playerIndex i32) {
	var state i32 = phx.STATE_TRANSLATE | phx.STATE_ROTATE

	var mass f32 = 0.01

	var skynoteCount i32 = i32.rand(1, 10)
	for i := 0; i < skynoteCount; i++ {
		var at mat.v3 = v3.normalize(v3.add(direction, v3.make(f32.rand() * 0.2 - 0.1, f32.rand() * 0.2 - 0.1, f32.rand() * 0.2 - 0.1)))
		var axis mat.v3 = v3.normalize(v3.rand())

		var force f32 = 10.0 + f32.rand() * 1.0
		var right mat.v3 = v3.make(0.5 + f32.rand() * 0.5, 0.0, 0.0)
		var top mat.v3 = v3.make(0.0, 0.5 + f32.rand() * 0.5, 0.0)
		var back mat.v3 = v3.make(0.0, 0.0, 0.5 + f32.rand() * 0.5)

		var acceleration mat.v3 = v3.mulf(at, force / mass)

		var miner i32 = phx.AddObject(phx.TYPE_PLANE, TAG_DOLLAR, playerIndex,
			state, position, v3.ZERO, acceleration,
			right, top, back, mass, 1.0, v4.make(axis.x, axis.y, axis.z, f32.rand() * 10.0), v4.ONE)
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func updatePlayersVisibility(dt f32)() {
	for i := 0; i < len(players); i++ {
		var phxPlayer i32 = players[i].phxObject
		var t mat.v3 = phx.GetObjectPosition(phxPlayer)
		var phxScale mat.v3 = phx.GetObjectScale(phxPlayer)
        players[i].visible = gfx.FrustumIntersectsSphere(frustum, t, phxScale.x) <= 0
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func updatePlayers(dt f32)() {
	prfUpdatePlayers = fps.CreateStartProfile(prfUpdatePlayers, "updatePlayers")

	var cameraAt mat.v3 = gam.CameraGetAt(camera)
	var cameraPos mat.v3 = gam.CameraGetPosition(camera)
	var invProj m44 = gam.CameraGetInvViewProj(camera)

	for i := 0; i < len(players); i++ {
		var phxPlayer i32 = players[i].phxObject
		var t mat.v3 = phx.GetObjectPosition(phxPlayer)
		var r mat.v4 = phx.GetObjectRotation(phxPlayer)
		var phxScale mat.v3 = phx.GetObjectScale(phxPlayer)
        var renderScale f32 = players[i].scale


        players[i].visible = gfx.FrustumIntersectsSphere(frustum, t, phxScale.x) <= 0

		players[i].position = t
		players[i].rotation = r
		players[i].at = phx.GetObjectAt(phxPlayer)
		players[i].ri = phx.GetObjectRight(phxPlayer)
		players[i].offset = v3.add(v3.mulf(players[i].at, 0.4), v3.make(1.0, 6.0, 0.0))
		players[i].camera = v3.add(players[i].offset, t)
		players[i].velocity = phx.GetObjectVelocity(phxPlayer)

		var q mat.v4
		q = q4.from_axis_angle(r.x, r.y, r.z, r.w)
		q = q4.mul(q, q4.from_axis_angle(0.0, 1.0, 0.0, v1.PI))
		players[i].world = m44.makef_SQT(renderScale, renderScale, renderScale, q.x, q.y, q.z, q.w, t.x, t.y - phxScale.y + 1.3, t.z)
		players[i].handTransform = m44.mulISSUE(
			m44.makef_SAT(skyminerScale, skyminerScale, skyminerScale, 1.0, 0.0, 0.0, -0.94, -1.4, 22.6, 3.6),
			m44.mulISSUE(gfx.ModelGetNodeTransform(players[i].idle.model, players[i].hand), players[i].world))

		players[i].weaponPos.x = players[i].handTransform.v30
		players[i].weaponPos.y = players[i].handTransform.v31
		players[i].weaponPos.z = players[i].handTransform.v32

		var playerYaw mat.v4 = q4.from_axis_angle(players[i].rotation.x, players[i].rotation.y, players[i].rotation.z, players[i].rotation.w)
		var targetYaw mat.v4
		var weaponAt mat.v3
		if i == currentPlayer {
			if currentCamera == CAMERA_FREE {
				weaponAt = players[i].at
				targetYaw = playerYaw
			} else if currentCamera == CAMERA_TPS {
				var aimDir mat.v4 = v4.make(players[i].aimPosition.x, players[i].aimPosition.y, 1.0, 1.0)
				aimDir = v4.transform(aimDir, invProj)
				weaponAt.x = aimDir.x / aimDir.w
				weaponAt.y = aimDir.y / aimDir.w
				weaponAt.z = aimDir.z / aimDir.w
				weaponAt = v3.normalize(v3.sub(weaponAt, players[i].camera))
				targetYaw = gam.CameraGetYawQuaternion(camera)
			} else if currentCamera == CAMERA_FPS {
				weaponAt = cameraAt
				targetYaw = gam.CameraGetYawQuaternion(camera)
			}
		} else {
			weaponAt = v3.sub(players[currentPlayer].camera, players[i].camera)
			var weaponAtLen f32 = v3.length(weaponAt)
			if weaponAtLen <= 0.0 {
				weaponAt = v3.GREEN
			} else {
				weaponAt = v3.divf(weaponAt, weaponAtLen)
			}
			weaponAt = v3.transform_vector(weaponAt, m44.make_rotate_x(ffx))
			var aimDir mat.v3 = v3.sub(players[i].position, players[currentPlayer].position)
			var aimDirLen f32 = v3.length(aimDir)
			if aimDirLen <= 0.0 {
				aimDir = v3.GREEN
			} else {
				aimDir.y = 0.0
				aimDir = v3.divf(aimDir, aimDirLen)
			}
			targetYaw = q4.from_vectors(v3.BLUE/*players[i].at*/, aimDir, v3.GREEN)
		}

		players[i].weaponAt = weaponAt

		var yawLength f32 = v4.length(v4.sub(targetYaw, playerYaw))
		if yawLength < 0.001 {
			players[i].yawTime = -1.0
			playerYaw = targetYaw
		} else {
			if players[i].yawTime < 0.0 {
				players[i].yawTime = 0.0
			}
			playerYaw = q4.lerp(playerYaw, targetYaw, players[i].yawTime)
			players[i].yawTime = players[i].yawTime + dt
			if players[i].yawTime > 1.0 {
				players[i].yawTime = -1.0
			}
		}

		playerYaw = q4.to_axis_angle(playerYaw.x, playerYaw.y, playerYaw.z, playerYaw.w)
		phx.SetObjectRotation(phxPlayer, playerYaw)
	}
	fps.StopProfile(prfUpdatePlayers)
}

var fireCount i32
func updateWeapons(dt f32)() {
	prfUpdateWeapons = fps.CreateStartProfile(prfUpdateWeapons, "updateWeapons")
	for i := 0; i < len(players); i++ {
		if currentPlayer != i && currentCamera != CAMERA_FREE {
			var cpuFire f32 = players[i].cpuFire
			//var cpuZdir f32 = players[i].cpuZdir
			if cpuFire > 4.0 {
				cpuFire = 0.0
				players[i].fireWeapon = 1
			}
			/*if cpuZdir > 1.0 {
				cpuZdir = 0.0
				if players[i].zdir >= 0.0 {
					players[i].zdir = 0.0 - 1.0
				} else {
					players[i].zdir = 1.0
				}
			}*/
			cpuFire = cpuFire + dt
			players[i].cpuFire = cpuFire
			//cpuZdir = cpuZdir + dt
		}
		players[i].fireAnimLength = gfx.AnimationGetMax(players[i].throw.anim)

		if players[i].fireWeapon > 0 && players[i].fireAnimTime < 0.0 && fireCount < 15 {
			players[i].fireAnimTime = 0.0
			gfx.AnimationSetTime(players[i].throw.anim, 0.0)
            fireCount = fireCount + 1
		}

		var nextFireAnimTime f32 = players[i].fireAnimTime + dt * 2.5
		if nextFireAnimTime >= players[i].fireAnimThrow && players[i].fireWeapon > 0 {
			if players[i].weapon == WEAPON_SKYMINER {
				fireSkyminer(players[i].weaponPos, players[i].weaponAt, i)
				players[i].fireWeapon = 0
			} else if players[i].weapon == WEAPON_SKYNOTE {
				fireSkynotes(players[i].weaponPos, players[i].weaponAt, i)
			}
		}
	}
	fps.StopProfile(prfUpdateWeapons)
}

func updatePositions(dt f32)() {
	prfUpdatePositions = fps.CreateStartProfile(prfUpdatePositions, "updatePositions")
	for i := 0; i < len(players); i++ {

		var at mat.v3
		var right mat.v3

		var xdir f32 = players[i].xdir
		var zdir f32 = players[i].zdir

		if i == currentPlayer {
			if currentCamera == CAMERA_FREE {
			} else if currentCamera == CAMERA_FPS {
				if xdir != 0.0 {
					at = players[i].at
				}
				if zdir != 0.0 {
					right = players[i].ri
				}

			} else if currentCamera == CAMERA_TPS {
				if xdir != 0.0 {
					at = gam.CameraGetAt(camera)
				}
				if zdir != 0.0 {
					right = gam.CameraGetRight(camera)
				}
			}
		} else {
			if xdir != 0.0 {
				at = players[i].at
			}
			if zdir != 0.0 {
				right = players[i].ri
			}
		}

		var acceleration mat.v3
		var dirlen f32 = xdir*xdir + zdir*zdir
		if dirlen > 0.0 {
			dirlen = f32.sqrt(dirlen)
			var nxdir f32 = xdir / dirlen
			var nzdir f32 = zdir / dirlen

			acceleration = v3.add(acceleration, v3.mulf(at, 0.2 * nxdir))
			acceleration = v3.add(acceleration, v3.mulf(right, 0.2 * nzdir))
		}
		acceleration.y = players[i].ydir * 0.5

		var phxPlayer i32 = players[i].phxObject
        //phx.SetObjectVelocity(phxPlayer, acceleration)
        phx.SetObjectMaxVelocity(phxPlayer, v3.make(200.0, 10000.0, 10000.0))
        phx.SetObjectMaxAcceleration(phxPlayer, v3.make(200.0, 100.0, 100.0))
		phx.SetObjectAcceleration(phxPlayer, acceleration)
		//var playerVelocity mat.v3 = players[i].velocity
		//var playerVelocityLength f32 = v3.length(playerVelocity)
		/*var maxVelocity f32 = 200.0
		if playerVelocityLength > maxVelocity {
			playerVelocity = v3.mulf(playerVelocity, maxVelocity / playerVelocityLength)
		}*/
		//phx.SetObjectVelocity(phxPlayer, playerVelocity)
	}
	fps.StopProfile(prfUpdatePositions)
}

func updateAnimations(dt f32)() {
	prfUpdateAnimations = fps.CreateStartProfile(prfUpdateAnimations, "updateAnimations")

	var playerCount i32 = len(players)
	for i := 0; i < playerCount; i++ {
		var player Player = players[i]
		var backwardAnim gfx.AnimationId = player.backward.anim

		var previousAnim gfx.AnimationId = player.currentAnim
		player.currentAnim = player.idle.anim

		player.backwardState = false
		if player.zdir > 0.0 {
			player.currentAnim = player.right.anim
		} else if player.zdir < 0.0 {
			player.currentAnim = player.left.anim
		}

		if player.xdir > 0.0 {
			player.currentAnim = backwardAnim
			player.backwardState = true
		} else if player.xdir < 0.0 {
			player.currentAnim = player.forward.anim
		}

		var currentDt f32 = dt
		if player.fireAnimTime >= 0.0 {
			player.currentAnim = player.throw.anim
			currentDt = dt * 2.5
			player.fireAnimTime = player.fireAnimTime + currentDt
		}

		if player.fireAnimTime > player.fireAnimLength {
			player.fireAnimTime = -1.0
		}

		var newPlayerPosition mat.v3 = phx.GetObjectPosition(player.phxObject)
		var oldPlayerPosition mat.v3 = player.oldPhxPosition

		var newVoidCount i32 = phx.GetObjectVoidCount(player.phxObject)
		var oldVoidCount i32 = player.oldVoidCount

		var jumping bool = newVoidCount > 5 && oldVoidCount >= 5

		var animLoop bool = true
		var animMax f32 = -1

		if newVoidCount > 5 {
			player.currentAnim = player.jump.anim
			animLoop = false
			animMax = gfx.AnimationGetMax(player.currentAnim)
			if newPlayerPosition.y > oldPlayerPosition.y {
				if jumping {
					animMax = 0.5 * animMax
//					gfx.AnimationSetTime(player.currentAnim, 0.0)
					//player.switchAnimTime = 0.0
				}
			} else if newPlayerPosition.y < oldPlayerPosition.y {
				if jumping {
				//	gfx.AnimationSetTime(player.currentAnim, 0.5 * animMax)
					//player.switchAnimTime = 0.0
				}
			}
		}

		player.oldPhxPosition = newPlayerPosition
		player.oldVoidCount = newVoidCount

		if previousAnim.animation != player.currentAnim.animation {
			gfx.AnimationSetTime(player.currentAnim, 0.0)
		}

		if player.currentAnim.animation != player.previousAnim.animation && player.switchAnimTime < 0.0 {
			player.switchAnimTime = 0.0
		}

		if player.switchAnimTime >= 0.0 {
			/*var newAnimMax f32 = animMax
			if newAnimMax < 0.0 {
				newAnimMax = gfx.AnimationGetMax(player.currentAnim)
			}
			newAnimMax = f32.max(newAnimMax, gfx.AnimationGetMax(player.runtimeAnim))*/
			var tmpAnim gfx.AnimationId = player.tmpAnim0
			if tmpAnim.animation == player.currentAnim.animation || player.tmpAnim0.animation == player.runtimeAnim.animation {
				tmpAnim = player.tmpAnim1
			}
			if player.tmpAnim1.animation == player.currentAnim.animation || player.tmpAnim1.animation == player.runtimeAnim.animation {
				tmpAnim = player.tmpAnim2
			}
			gfx.AnimationUpdate(player.currentAnim, currentDt, animLoop, -1.0)
			if player.currentAnim.animation == backwardAnim.animation && i == 0 {
				var q mat.v4 = gfx.AnimationGetJointRotation(player.currentAnim, player.spine)
				q = q4.mul(q, player.backwardQuat)
				gfx.AnimationSetJointRotation(player.currentAnim, player.spine, q)
			}

			if gfx.AnimationGetRuntime(player.runtimeAnim) == false {
				gfx.AnimationUpdate(player.runtimeAnim, dt, animLoop, -1.0)
			}
			if player.runtimeAnim.animation == backwardAnim.animation && i == 0{
				var q mat.v4 = gfx.AnimationGetJointRotation(player.runtimeAnim, player.spine)
				q = q4.mul(q, player.backwardQuat)
				gfx.AnimationSetJointRotation(player.runtimeAnim, player.spine, q)
			}

			gfx.AnimationMorph(player.runtimeAnim, player.currentAnim, tmpAnim, player.switchAnimTime)
			player.switchAnimTime = player.switchAnimTime + dt * 5.0
			player.runtimeAnim = tmpAnim
		} else {
			gfx.AnimationUpdate(player.currentAnim, currentDt, animLoop, animMax)
			if player.currentAnim.animation == backwardAnim.animation && i == 0 {
				var q mat.v4 = gfx.AnimationGetJointRotation(player.currentAnim, player.spine)
				q = q4.mul(q, player.backwardQuat)
				gfx.AnimationSetJointRotation(player.currentAnim, player.spine, q)
			}
			player.runtimeAnim = player.currentAnim
		}

		if player.switchAnimTime >= 1.0 {
			player.switchAnimTime = -1.0
			player.previousAnim = player.currentAnim
			player.runtimeAnim = player.currentAnim
		}
		players[i] = player
	}
	fps.StopProfile(prfUpdateAnimations)
}

var firstGameUpdate bool = true
var firstLevelUpdate bool = true
func gameOnUpdate(controlIndex i32, controlAction i32) {
    prfGameOnUpdate = fps.CreateStartProfile(prfGameOnUpdate, "gameOnUpdate")

    if firstGameUpdate {
        firstGameUpdate = false
        loadGame()
    }

    if firstLevelUpdate {
        firstLevelUpdate = false
        loadLevel()
    }

	var dts f64 = fps.DeltaSecond()
	var dt f32 = f64.f32(dts)

	updatePositions(dt)
	updateAnimations(dt)
	//-------------------------------------------------------------------------
	// PhxUpdate
	//-------------------------------------------------------------------------
	prfPhxUpdate = fps.CreateStartProfile(prfPhxUpdate, "PhxUpdate")
	phx.Update(fps.DeltaNano())
	//if phx.COLLIDED { // TODO : remove hardcode
	//	players[currentPlayer].jumpingState = false
	//}
	fps.StopProfile(prfPhxUpdate)


    //gfx.ModelUpdate(levels[currentLevel].model, gfx.InvalidAnim()

	var scaleBox f32 = 50.0
	for i:= aimCount; i < aimMax; i++ {
		newAimBox(v3.add(v3.make((2.0 * f32.rand() - 1.0) * scaleBox, scaleBox + f32.rand() * 5.0, (2.0 * f32.rand() - 1.0) * scaleBox),
			players[currentPlayer].position))
		aimCount = aimCount + 1
	}

	updatePlayers(dt)
	updateWeapons(dt)

	//-------------------------------------------------------------------------
	// CameraUpdate
	//-------------------------------------------------------------------------
	prfCameraUpdate = fps.CreateStartProfile(prfCameraUpdate, "CameraUpdate")
	if currentCamera == CAMERA_FREE {
		gam.FreeCameraUpdate(camera, dts, 1.0, 3.0)
	} else if currentCamera == CAMERA_FPS {
		gam.FpsCameraUpdate(camera, dts, players[currentPlayer].camera)
	} else if currentCamera == CAMERA_TPS {
		gam.TpsCameraUpdate(camera, dts, players[currentPlayer].camera, 30.0)
	}
	fps.StopProfile(prfCameraUpdate)

    if debugFrustum == false {
        gfx.FrustumUpdate(frustum, gam.CameraGetInvViewProj(camera))
    }

    updatePlayersVisibility(dt)

	//-------------------------------------------------------------------------
	// PhxRemove
	//-------------------------------------------------------------------------
    prfPhxEmit = fps.CreateStartProfile(prfPhxEmit, "PhxEmit")
	phxRemoveList = resize(phxRemoveList, 0)

	var collisions []phx.Collision = phx.g_collisions
	var collisionCount i32 = len(collisions)
    for colIndex := 0; colIndex < collisionCount; colIndex++ {
		var col phx.Collision = collisions[colIndex]
		if col.LeftTag == TAG_MINER && (col.RightTag == TAG_LEVEL || col.RightTag == TAG_GROUND) {
			phxRemoveList = append(phxRemoveList, col.LeftIndex)
			emitSmoke(col.Position, col.Normal, col.LeftTag2)
		} else if col.LeftTag == TAG_MINER && col.RightTag == TAG_MINER {
			phxRemoveList = append(phxRemoveList, col.LeftIndex)
			emitSmoke(col.Position, col.Normal, col.LeftTag2)
			phxRemoveList = append(phxRemoveList, col.RightIndex)
			emitSmoke(col.Position, col.Normal, col.RightTag2)
		} else if col.LeftTag == TAG_MINER && col.RightTag == TAG_PLAYER {
			if col.LeftTag2 != col.RightTag2 {
				phxRemoveList = append(phxRemoveList, col.LeftIndex)
				emitSmoke(col.Position, col.Normal, col.LeftTag2)
				var rightTag2 i32 = col.RightTag2
				if rightTag2 == currentCPU || rightTag2 == currentCPU2 {
					phx.SetObjectPosition(col.RightIndex, v3.add(players[rightTag2].position, v3.make(v1.srand() * 50.0, 0.0, v1.srand() * 50.0)))
				}
			}
		} else if col.LeftTag == TAG_PLAYER && col.RightTag == TAG_MINER {
			if col.LeftTag2 != col.RightTag2 {
				phxRemoveList = append(phxRemoveList, col.RightIndex)
				emitSmoke(col.Position, col.Normal, col.RightTag2)
				var leftTag2 i32 = col.LeftTag2
				if leftTag2 == currentCPU || leftTag2 == currentCPU2{
					phx.SetObjectPosition(col.LeftIndex, v3.add(players[leftTag2].position, v3.make(v1.srand() * 50.0, 0.0, v1.srand() * 50.0)))
				}
			}
		} else if col.LeftTag == TAG_MINER {
			phxRemoveList = append(phxRemoveList, col.LeftIndex)
			emitSmoke(col.Position, col.Normal, col.LeftTag2)
		} else if col.RightTag == TAG_MINER {
			phxRemoveList = append(phxRemoveList, col.RightIndex)
			emitSmoke(col.Position, col.Normal, col.RightTag2)
		}
	}
	fps.StopProfile(prfPhxEmit)
	prfPhxRemove = fps.CreateStartProfile(prfPhxRemove, "PhxRemove")

	phxSortedList = resize(phxSortedList, 0)
	var removeCount i32 = len(phxRemoveList)
	for i := 0; i < removeCount; i++ {
		var sortedCount i32 = len(phxSortedList)
		var remove i32 = phxRemoveList[i]
		var duplicate i32 = 0
		for k := 0; k < sortedCount; k++ {
			var sorted i32 = phxSortedList[k]
			if remove < sorted {
				phxSortedList = insert(phxSortedList, k, remove)
				k = sortedCount
			}
		}

		if sortedCount == len(phxSortedList) {
			phxSortedList = append(phxSortedList, remove)
		}
	}

	var sortedCount i32 = len(phxSortedList)
	if sortedCount > 0 {
		var previousRemoved i32 = -1
		for i := 0; i < sortedCount; i++ {
			var toRemove i32 = phxSortedList[sortedCount - i - 1]
			if toRemove != previousRemoved {
				if phx.GetObjectTag(toRemove) == TAG_AIM {
					aimCount = aimCount - 1
				}
				phx.RemoveObject(toRemove)
                fireCount = fireCount - 1
			}
			previousRemoved = toRemove
		}
	}
	fps.StopProfile(prfPhxRemove)
	//-------------------------------------------------------------------------
	// ModelUpdate
	//-------------------------------------------------------------------------
	prfModelUpdate = fps.CreateStartProfile(prfModelUpdate, "ModelUpdate")
	gfx.ModelUpdate(skyminerModel, gfx.AnimationInvalid(), dt, true)
	for i := 0; i < len(players); i++ {
		gfx.ModelUpdate(players[i].idle.model, players[i].runtimeAnim, dt, true)
	}
	fps.StopProfile(prfModelUpdate)

	//-------------------------------------------------------------------------
	// ParticleUpdate
	//-------------------------------------------------------------------------
	prfParticleUpdate = fps.CreateStartProfile(prfParticleUpdate, "ParticleUpdate")
	gfx.ParticleUpdate(dt)
	fps.StopProfile(prfParticleUpdate)
	fps.StopProfile(prfGameOnUpdate)

    if isModeLight == false {
        gfx.OctreeUpdate(levels[currentLevel].gfxOctree, frustum, 2)
        gfx.OctreeUpdate(levels[currentLevel].phxOctree, frustum, 2)
    }

    var cameraPosition mat.v3 = gam.CameraGetPosition(camera)
    skyWorld = m44.make_translate(cameraPosition.x, cameraPosition.y, cameraPosition.z)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnRender(controlIndex i32, controlAction i32) {
	prfGameOnRender = fps.CreateStartProfile(prfGameOnRender, "gameOnRender")

	var view m44 = gam.CameraGetView(camera)
	var projection m44 = gam.CameraGetProjection(camera)
	var cameraPosition mat.v3 = gam.CameraGetPosition(camera)

//-------------------------------------------------------------------------
// Opaque
//-------------------------------------------------------------------------

	//-------------------------------------------------------------------------
	// RenderClear
	//-------------------------------------------------------------------------
	prfClear = fps.CreateStartProfile(prfClear, "RenderClear")
	gfx.TargetBind(opaqueTarget)
	gfx.ColorWrite(true, true, true, true)
	gfx.DepthWrite(true)
	gfx.Clear(gfx.COLOR_BUFFER_BIT | gfx.DEPTH_BUFFER_BIT, v4.ALPHA, 1.0D, 0)
	//gfx.ClearBufferUI(gfx.COLOR, 0, 0U, 0U, 0U, 1U)
	//gfx.ClearBufferF(gfx.DEPTH, 0, 1.0, 1.0, 1.0, 1.0)
	gfx.DisableBlending()
	gfx.DisableStencil()
	fps.StopProfile(prfClear)

	//-------------------------------------------------------------------------
	// RenderSky
	//-------------------------------------------------------------------------
	prfRenderSky = fps.CreateStartProfile(prfRenderSky, "sky")
	gfx.DepthState(false, gfx.LESS, false)
	gfx.EffectUse(gfx.g_fxSky)
    var skyTexture gfx.TextureId = skies[currentSky].specular
    var skySampler gfx.SamplerState = gfx.g_linearClamp
    if debugSky {
        skyTexture = skies[currentSky].diffuse
        skySampler = gfx.g_linear0Clamp
    }
	gfx.EffectAssignTexture(gfx.g_fxSky, gfx.SAMPLER_ENV_DIFFUSE, skyTexture, skySampler)
	gfx.EffectAssignM44(gfx.g_fxSky, gfx.UNIFORM_WORLD, skyWorld, false)
	gfx.EffectAssignM44(gfx.g_fxSky, gfx.UNIFORM_VIEW, view, false)
	gfx.EffectAssignM44(gfx.g_fxSky, gfx.UNIFORM_PROJECTION, projection, false)
	gfx.EffectAssignV4(gfx.g_fxSky, gfx.UNIFORM_CAMERA_POSITION, v4.make_v31(cameraPosition, 1.0))
	gfx.MeshRender(skyMesh)
	fps.StopProfile(prfRenderSky)

	//-------------------------------------------------------------------------
	// RenderGround
	//-------------------------------------------------------------------------
	prfRenderGround = fps.CreateStartProfile(prfRenderGround, "ground")
	gfx.DepthState(true, gfx.LESS, true)
	gfx.EffectUse(gfx.g_fxTexture3D)
	gfx.EffectAssignTexture(gfx.g_fxTexture3D, gfx.SAMPLER_COLOR_0, texture, gfx.g_linearWrap)
	gfx.EffectAssignM44(gfx.g_fxTexture3D, gfx.UNIFORM_VIEW, view, false)
	gfx.EffectAssignM44(gfx.g_fxTexture3D, gfx.UNIFORM_PROJECTION, projection, false)
	gfx.EffectAssignM44(gfx.g_fxTexture3D, gfx.UNIFORM_WORLD,
		m44.makev_AT(phx.GetObjectRotation(phxGround0), phx.GetObjectPosition(phxGround0)), false)
	gfx.MeshRender(groundMesh)
	gfx.EffectAssignM44(gfx.g_fxTexture3D, gfx.UNIFORM_WORLD,
		m44.makev_AT(phx.GetObjectRotation(phxGround1), phx.GetObjectPosition(phxGround1)), false)
	gfx.MeshRender(groundMesh)
	fps.StopProfile(prfRenderGround)

	//-------------------------------------------------------------------------
    // LevelRender
	//-------------------------------------------------------------------------
	if isModeLight == false {
        var levelOctree gfx.OctreeId = levels[currentLevel].gfxOctree
        gfx.OctreeRender(levelOctree, m44.IDENTITY, view, projection,
        	skies[currentSky].specular, skies[currentSky].diffuse, brdf, v4.make_v31(cameraPosition, 1.0), 1.0)
        if debugFrustum {
            gfx.FrustumRender(frustum, m44.IDENTITY, view, projection)
        }
    }



	//-------------------------------------------------------------------------
	// PhxRender
	//-------------------------------------------------------------------------
	prfPhxRender = fps.CreateStartProfile(prfPhxRender, "PhxRender")
	phx.Render(m44.IDENTITY, view, projection)
	fps.StopProfile(prfPhxRender)

	//-------------------------------------------------------------------------
	// RenderPlayers
	//-------------------------------------------------------------------------
	prfRenderPlayers = fps.CreateStartProfile(prfRenderPlayers, "RenderPlayers")
    var renderPlayerCount i32 = 0
	for i := 0; i < len(players); i++ {
		var player Player = players[i]
        if player.visible == true {
    		var currentModel gfx.ModelId = player.idle.model
	    	gfx.ModelSetView(currentModel, view)
		    gfx.ModelSetProjection(currentModel, projection)
		    gfx.ModelSetEnvironmentSpecular(currentModel, skies[currentSky].specular)
		    gfx.ModelSetEnvironmentDiffuse(currentModel, skies[currentSky].diffuse)
		    gfx.ModelSetBRDF(currentModel, brdf)
		    gfx.ModelSetCameraPosition(currentModel, cameraPosition)
		    gfx.ModelSetWorld(currentModel, player.world)
            gfx.ModelSetExposure(currentModel, 1.0)
            gfx.ModelRender(currentModel)
            renderPlayerCount++
	    }
    }
	fps.StopProfile(prfRenderPlayers)

	//-------------------------------------------------------------------------
	// RenderWeapons
	//-------------------------------------------------------------------------
	prfRenderWeapons = fps.CreateStartProfile(prfRenderWeapons, "RenderWeapons")
   	gfx.ModelSetView(skyminerModel, view)
	gfx.ModelSetProjection(skyminerModel, projection)
	gfx.ModelSetEnvironmentSpecular(skyminerModel, skies[currentSky].specular)
	gfx.ModelSetEnvironmentDiffuse(skyminerModel, skies[currentSky].diffuse)
	gfx.ModelSetBRDF(skyminerModel, brdf)
	gfx.ModelSetCameraPosition(skyminerModel, cameraPosition)
    gfx.ModelSetExposure(skyminerModel, 1.0)
	for i := 0; i < len(players); i++ {
		gfx.ModelSetWorld(skyminerModel, players[i].handTransform)
		if players[i].fireAnimTime >= 0.0 {
			gfx.EnableBlending(gfx.SRC_ALPHA, gfx.ONE_MINUS_SRC_ALPHA)
			gfx.DepthState(true, gfx.LESS, false)
			var fireAnimAlpha f32 = 1.0
			if players[i].fireAnimTime >= players[i].fireAnimThrow && players[i].fireAnimTime <= players[i].fireAnimThresh {
				fireAnimAlpha = 0.0
			} else if players[i].fireAnimTime >= players[i].fireAnimThresh {
				fireAnimAlpha = (players[i].fireAnimTime - players[i].fireAnimThresh) / (players[i].fireAnimLength - players[i].fireAnimThresh)
			}
			gfx.modelRender(skyminerModel, gfx.ModelGetMeshes(skyminerModel), fireAnimAlpha)
		} else {
			gfx.ModelRender(skyminerModel)
		}
	}
	fps.StopProfile(prfRenderWeapons)

	//-------------------------------------------------------------------------
	// RenderSkyminers
	//-------------------------------------------------------------------------
	prfRenderSkyminers = fps.CreateStartProfile(prfRenderSkyminers, "RenderSkyminers")
	var skyminerCount i32 = 0
	var minerScale mat.v3 = v3.makef(skyminerScale * 0.1)
	for i := 0; i < phx.GetObjectCount(); i++ {
		if phx.GetObjectTag(i) == TAG_MINER {
			gfx.ModelSetWorld(skyminerModel, m44.makev_SAT(minerScale, phx.GetObjectRotation(i), phx.GetObjectPosition(i)))
			gfx.ModelRender(skyminerModel)
			skyminerCount = skyminerCount + 1
		}
	}
	fps.StopProfile(prfRenderSkyminers)

	//-------------------------------------------------------------------------
	// RenderSkynotes
	//-------------------------------------------------------------------------
	prfRenderSkynotes = fps.CreateStartProfile(prfRenderSkynotes, "RenderSkynotes")
	var size mat.v3 = v3.mulf(v3.make(1.0, 1.0, 0.5), 0.75)
	gfx.MeshBegin(dollarMesh)
	for i := 0; i < phx.GetObjectCount(); i++ {
		if phx.GetObjectTag(i) == TAG_DOLLAR {
			var rotation mat.m44 = m44.from_axis_angle_v4(phx.GetObjectRotation(i))
			var right mat.v3 = v3.transform_vector(v3.make(size.x, 0.0, 0.0), rotation)
			var top mat.v3 = v3.transform_vector(v3.make(0.0, size.y, 0.0), rotation)
			var back mat.v3 = v3.transform_vector(v3.make(0.0, 0.0, size.z), rotation)
			gfx.MeshAppendPlane(dollarMesh, false, true, phx.GetObjectPosition(i), right, top, back, 2, 2, v4.make(0.5, 0.5, 1.0, 1.0), v4.ONE)
		}
	}
	gfx.MeshEnd(dollarMesh)
	gfx.DepthState(true, gfx.LESS, true)

	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_COLOR_UNI, true)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_COLOR_VTX, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_COLOR_MAP, true)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_PBR_UNI, true)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_PBR_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_EMISSIVE_UNI, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_EMISSIVE_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_NORMAL_VTX, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_NORMAL_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_TANGENT_VTX, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_OCCLUSION_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_SKIN, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_DEBUG_A, true)

	var effect gfx.EffectId = gfx.TemplateInstance(gfx.g_tfxPbr)

	gfx.EffectUse(effect)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_COLOR_0, dollar, gfx.g_linearWrap)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_ENV_SPECULAR, skies[currentSky].specular, gfx.g_linearClamp)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_ENV_DIFFUSE, skies[currentSky].diffuse, gfx.g_linear0Clamp)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_BRDF, brdf, gfx.g_linear0Clamp)

	gfx.EffectAssignV4(effect, gfx.UNIFORM_COLOR, v4.ONE)
	gfx.EffectAssignV4(effect, gfx.UNIFORM_METAL_ROUGH, v4.make(0.0, 1.0, 0.0, 0.0))
	gfx.EffectAssignV4(effect, gfx.UNIFORM_CAMERA_POSITION, v4.make_v31(cameraPosition, 1.0))

	gfx.EffectAssignM44(effect, gfx.UNIFORM_WORLD, m44.IDENTITY, false)
	gfx.EffectAssignM44(effect, gfx.UNIFORM_VIEW, view, false)
	gfx.EffectAssignM44(effect, gfx.UNIFORM_PROJECTION, projection, false)
	gfx.MeshSetCulling(dollarMesh, gfx.CW, gfx.NONE)
	gfx.MeshRender(dollarMesh)
	fps.StopProfile(prfRenderSkynotes)

//-------------------------------------------------------------------------
// Edge
//-------------------------------------------------------------------------
	gfx.TargetBind(edgeTarget)
	gfx.Clear(gfx.COLOR_BUFFER_BIT, v4.ZERO, 0.0D, 0)
	gfx.DisableDepth()
	gfx.DisableBlending()
	gfx.DisableStencil()
	gfx.EffectUse(gfx.g_fxEdge)
	gfx.EffectAssignTexture(gfx.g_fxEdge, gfx.SAMPLER_COLOR_3, gfx.TargetGetDepth(opaqueTarget), gfx.g_nearest0Clamp)
	gfx.EffectAssignV4(gfx.g_fxEdge, gfx.UNIFORM_TARGET_SIZE, gfx.TargetGetSize(opaqueTarget))
	gfx.MeshRender(gfx.g_fullscreenQuad)

//-------------------------------------------------------------------------
// AlphaFull
//-------------------------------------------------------------------------
	prfAlphaFull = fps.CreateStartProfile(prfAlphaFull, "AlphaFull")
	gfx.TargetBind(alphaFullTarget)
	gfx.ColorWrite(true, true, true, true)
	gfx.DisableBlending()
	gfx.DisableDepth()
	gfx.StencilWrite(255)
	gfx.ClearBufferI(gfx.STENCIL, 0, 0, 0, 0, 0)
	gfx.ClearBufferF(gfx.COLOR, 0, 0.0, 0.0, 0.0, 0.0)
	gfx.ClearBufferF(gfx.COLOR, 1, 0.0, 0.0, 0.0, 0.0)

	writeEdges()

	// ParticleRender
	gfx.ColorWrite(true, true, true, true)
	gfx.EnableBlendingSeparate(gfx.ONE, gfx.ONE, gfx.ONE, gfx.ONE)
	//gfx.EnableBlendingSeparate(gfx.ONE, gfx.ONE, gfx.ZERO, gfx.ONE_MINUS_SRC_ALPHA)
	gfx.DepthState(true, gfx.LESS, false)
	gfx.StencilState(true, gfx.EQUAL, 1, 1, gfx.KEEP, gfx.KEEP, gfx.KEEP, 0)
	gfx.ParticleRender(view, projection, cameraPosition, opaqueTarget, v4.make(ffx, ffy, ffz, ffr),
		gfx.TargetGetWidth(alphaFullTarget), gfx.TargetGetHeight(alphaFullTarget))
	fps.StopProfile(prfAlphaFull)


//-------------------------------------------------------------------------
// AlphaHalf
//-------------------------------------------------------------------------
	prfAlphaHalf = fps.CreateStartProfile(prfAlphaHalf, "AlphaHalf")
	gfx.TargetBind(alphaTarget)
	gfx.ColorWrite(true, true, true, true)
	gfx.DisableBlending()
	gfx.DisableDepth()
	gfx.StencilWrite(255)
	gfx.ClearBufferI(gfx.STENCIL, 0, 0, 0, 0, 0)
	gfx.ClearBufferF(gfx.COLOR, 0, 0.0, 0.0, 0.0, 0.0)
	gfx.ClearBufferF(gfx.COLOR, 1, 0.0, 0.0, 0.0, 0.0)

	//writeEdges()

	// ParticleRender
	gfx.ColorWrite(true, true, true, true)
	gfx.EnableBlendingSeparate(gfx.ONE, gfx.ONE, gfx.ONE, gfx.ONE)
	//gfx.EnableBlendingSeparate(gfx.ONE, gfx.ONE, gfx.ZERO, gfx.ONE_MINUS_SRC_ALPHA)
	gfx.DepthState(true, gfx.LESS, false)
	gfx.DisableStencil()
	//gfx.StencilState(true, gfx.EQUAL, 0, 1, gfx.KEEP, gfx.KEEP, gfx.KEEP, 0)
	gfx.ParticleRender(view, projection, cameraPosition, opaqueTarget, v4.make(ffx, ffy, ffz, ffr),
		gfx.TargetGetWidth(alphaTarget), gfx.TargetGetHeight(alphaTarget))
	fps.StopProfile(prfAlphaHalf)

//-------------------------------------------------------------------------
// Merge
//-------------------------------------------------------------------------
	gfx.TargetBind(mergeTarget)
	gui.g_renderExTarget = mergeTarget
	gfx.ColorWrite(true, true, true, true)
	gfx.DisableBlending()
	gfx.DisableDepth()
	gfx.StencilWrite(255)
	gfx.Clear(gfx.COLOR_BUFFER_BIT | gfx.STENCIL_BUFFER_BIT, v4.ZERO, 0.0D, 0)

	writeEdges()

	gfx.EffectUse(gfx.g_fxMerge)
	gfx.EffectAssignTexture(gfx.g_fxMerge, gfx.SAMPLER_COLOR_0, gfx.TargetGetColor(opaqueTarget, 0), gfx.g_nearest0Clamp)
	gfx.EffectAssignV4(gfx.g_fxMerge, gfx.UNIFORM_DEBUG_0, v4.make(ffx, ffy, ffz, ffr))

	gfx.ColorWrite(true, true, true, true)

	gfx.StencilState(true, gfx.EQUAL, 1, 1, gfx.KEEP, gfx.KEEP, gfx.KEEP, 0)
	gfx.EffectAssignTexture(gfx.g_fxMerge, gfx.SAMPLER_COLOR_1, gfx.TargetGetColor(alphaFullTarget, 0), gfx.g_nearest0Clamp)
	gfx.EffectAssignTexture(gfx.g_fxMerge, gfx.SAMPLER_COLOR_2, gfx.TargetGetColor(alphaFullTarget, 1), gfx.g_nearest0Clamp)
	gfx.MeshRender(gfx.g_fullscreenQuad)

	gfx.StencilState(true, gfx.EQUAL, 0, 1, gfx.KEEP, gfx.KEEP, gfx.KEEP, 0)
	gfx.EffectAssignTexture(gfx.g_fxMerge, gfx.SAMPLER_COLOR_1, gfx.TargetGetColor(alphaTarget, 0), gfx.g_nearest0Clamp)
	gfx.EffectAssignTexture(gfx.g_fxMerge, gfx.SAMPLER_COLOR_2, gfx.TargetGetColor(alphaTarget, 1), gfx.g_nearest0Clamp)
	gfx.MeshRender(gfx.g_fullscreenQuad)

	fps.StopProfile(prfGameOnRender)
}

func writeEdges()() {
	gfx.ColorWrite(false, false, false, false)
	gfx.DisableBlending()
	gfx.DisableDepth()
	gfx.StencilState(true, gfx.ALWAYS, 1, 1, gfx.KEEP, gfx.KEEP, gfx.REPLACE, 1)

	gfx.EffectUse(gfx.g_fxStencil)
	gfx.EffectAssignTexture(gfx.g_fxStencil, gfx.SAMPLER_COLOR_0, gfx.TargetGetColor(edgeTarget, 0), gfx.g_nearest0Clamp)
	gfx.MeshRender(gfx.g_fullscreenQuad)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func loadModel(path str, filename str, options i32) (out gfx.ModelId) {
	printf("loading '%s/%s'\n", path, filename)
	out = gfx.ModelCreateFromFile(sprintf("%s/models/%s/", app.DataDir(), path), filename, options)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func animCreate(name str, options i32) (out Anim) {
	out.model = loadModel(name, "scene.gltf", options)
	out.anim = gfx.ModelGetAnimation(out.model, 0)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func skyCreate(name str) {
    var sky Sky
    sky.name = name
    sky.specular = gfx.InvalidTexture()
    sky.diffuse = gfx.InvalidTexture()
    sky.loaded = false
    skies = append(skies, sky)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func characterCreate(name str, scale f32, spine str, torso str, shoulder str, hand str, backwardQuat mat.v4) {
    var character Player
    character.name = name
    character.scale = scale
    character.spineName = spine
    character.torsoName = torso
    character.shoulderName = shoulder
    character.handName = hand
    character.backwardQuat = backwardQuat
    characters = append(characters, character)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func levelCreate(gfxName str, gfxLevel i32, phxName str, phxLevel i32) {
    var level Level
    level.gfxName = sprintf("%s/models/%s/octree_lod_%d.oct", app.DataDir(), gfxName, gfxLevel)
    level.phxName = sprintf("%s/models/%s/octree_lod_%d.oct", app.DataDir(), phxName, phxLevel)
    levels = append(levels, level)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func playerCreate(playerIndex i32, characterIndex i32) {
    var characterName str = characters[characterIndex].name
    var characterCount i32 = len(characters)
    var loadedChar i32 = -1
    for i := 0; i < characterCount; i++ {
        if characters[i].name == characterName {
            loadedChar = i
            i = characterCount
        }
    }

    if loadedChar != -1 {
        if characters[loadedChar].loaded {
            players = append(players, characters[loadedChar])
        } else {
	        var player Player = characters[characterIndex]
	        player.idle = animCreate(sprintf("%s/idle", characterName), gfx.MODEL_GEOMETRY | gfx.MODEL_ANIMATION)
	        player.jump = animCreate(sprintf("%s/jump", characterName), gfx.MODEL_ANIMATION)
	        player.throw = animCreate(sprintf("%s/throw", characterName), gfx.MODEL_ANIMATION)
	        player.forward = animCreate(sprintf("%s/forward", characterName), gfx.MODEL_ANIMATION)
	        player.backward = animCreate(sprintf("%s/backward", characterName), gfx.MODEL_ANIMATION)
	        player.left = animCreate(sprintf("%s/left", characterName), gfx.MODEL_ANIMATION)
	        player.right = animCreate(sprintf("%s/right", characterName), gfx.MODEL_ANIMATION)
	        player.cpuFire = f32.rand() * 2.0

	        var model gfx.ModelId = player.idle.model
	        player.spine = gfx.ModelGetNodeByName(model, player.spineName)
	        player.torso = gfx.ModelGetNodeByName(model, player.torsoName)
	        player.shoulder = gfx.ModelGetNodeByName(model, player.shoulderName)
	        player.hand = gfx.ModelGetNodeByName(model, player.handName)

	        player.yawTime = -1.0
	        player.tmpAnim0 = gfx.AnimationCreate()
	        gfx.AnimationSetRuntime(player.tmpAnim0, true)

	        player.tmpAnim1 = gfx.AnimationCreate()
	        gfx.AnimationSetRuntime(player.tmpAnim1, true)

	        player.tmpAnim2 = gfx.AnimationCreate()
	        gfx.AnimationSetRuntime(player.tmpAnim2, true)

            player.color = v4.make(f32.rand(), f32.rand(), f32.rand(), 1.0)

            var playerSize f32 = 9.8
	        player.phxObject = phx.AddObject(phx.TYPE_ELLIPSE, TAG_PLAYER, len(players),
	        	phx.STATE_TRANSLATE | phx.STATE_DEBUG | phx.STATE_DEBUG_WIRE | phx.STATE_DEBUG_COLOR,
	        	v3.make(v1.srand() * 100.0, 4.0 + f32.rand() * 2.0, v1.srand() * 100.0), v3.ZERO, v3.ZERO,
	        	v3.make(playerSize, 0.0, 0.0), v3.make(0.0, playerSize, 0.0), v3.make(0.0, 0.0, playerSize),
	        	75.0 + f32.rand() * 50.0, 1.0, v4.make(0.0, 0.0, 1.0, 0.0), player.color)

            //phx.SetObjectMaxVelocity(player.phxObject, v3.make(1000.0, 3.0, 2.0))
            //phx.SetObjectMaxAcceleration(player.phxObject, v3.make(1000.0, 15.0, 10.0))
            if (playerIndex == currentPlayer) {
                phx.SetObjectPosition(player.phxObject, v3.make(-786.0, 3000.0, -409.0))
               }

	        player.currentAnim = player.idle.anim
	        player.runtimeAnim = player.currentAnim
	        player.previousAnim = player.currentAnim

	        player.fireWeapon = 0
	        player.fireAnimTime = -1.0
	        player.fireAnimLength = -1.0
	        player.fireAnimThresh = 1.1
	        player.fireAnimThrow = 0.65

	        players = append(players, player)
            characters[loadedChar] = player
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnParse(i i32, argc i32) {
    if len(gameModeNames) == 0 {
        gameModeNames = []str {"menu", "game", "light", "debug", "video"}
        gameModeValues = []i32 {GAME_MODE_MENU, GAME_MODE_GAME, GAME_MODE_LIGHT, GAME_MODE_DEBUG, GAME_MODE_VIDEO}
        app.SetUserHelp("++gmode : Game Mode flag : menu, game, light, debug\n")
    }

    app.SetCurrentArgIsValid(0)
    var arg str = app.GetCurrentArg()
    if args.Flags(arg, "gmode", &gameMode, &gameModeMatch, gameModeNames, gameModeValues) {
        app.SetCurrentArgIsValid(1)
        var allModes bool = (gameMode == 0) || (gameMode == GAME_MODE_LIGHT) || (gameMode == GAME_MODE_DEBUG) || (gameMode == GAME_MODE_VIDEO)
 if ((gameMode & GAME_MODE_MENU) != 0) || allModes {
            hasModeMenu = true
        }
        if ((gameMode & GAME_MODE_GAME) != 0) || allModes {
            hasModeGame = true
        }
        if ((gameMode & GAME_MODE_LIGHT) != 0) {
            isModeLight = true
        }
        if ((gameMode & GAME_MODE_DEBUG) != 0) {
            isModeDebug = true
        }
        if ((gameMode & GAME_MODE_VIDEO) != 0) {
            isModeVideo = true
        }
    }
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnStart(window str) {
    //StartCPUProfile("skylight_init", 100)
    app.Init()

	phx.Init(30U, -0.98)

    loadMenu()
    if isModeVideo {
        gameOnUpdate(0, 0)
    }
    //StopCPUProfile("skylight_init")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func loadGame()() {
	var width i32 = app.Width()
	var height i32 = app.Height()

	var scale i32 = 2

	var halfWidth i32 = width / scale
	var halfHeight i32 = height / scale

	edgeTarget = gfx.TargetCreate(1, width, height, scale, true)
	var edgeTexture TextureId = gfx.TextureCreate("", gfx.FORMAT_R8, halfWidth, halfHeight, 0, true, false)
	gfx.TextureSamplerState(edgeTexture, gfx.g_nearest0Clamp)
	gfx.TargetAttachColor(edgeTarget, edgeTexture, 0)

	opaqueTarget = gfx.TargetCreate(1, width, height, 1, true)
	var opaque0 TextureId = gfx.TextureCreate("", gfx.FORMAT_R8_G8_B8_A8, width, height, 0, true, false)
	gfx.TextureSamplerState(opaque0, gfx.g_nearest0Clamp)
	gfx.TargetAttachColor(opaqueTarget, opaque0, 0)
	var opaqueDepthTexture gfx.TextureId = gfx.TextureCreate("", gfx.FORMAT_DEPTH24, width, height, 0, true, false)
	gfx.TargetAttachDepth(opaqueTarget, opaqueDepthTexture)

	alphaFullTarget = gfx.TargetCreate(2, width, height, 1, true)
	var alphaFull0 TextureId = gfx.TextureCreate("", gfx.FORMAT_RGBA_16F, width, height, 0, true, false)
	gfx.TextureSamplerState(alphaFull0, gfx.g_linear0Wrap)
	gfx.TargetAttachColor(alphaFullTarget, alphaFull0, 0)
	var alphaFull1 TextureId = gfx.TextureCreate("", gfx.FORMAT_RGBA_16F, width, height, 0, true, false)
	gfx.TextureSamplerState(alphaFull1, gfx.g_linear0Wrap)
	gfx.TargetAttachColor(alphaFullTarget, alphaFull1, 1)
	var alphaFullStencilTexture TextureId = gfx.TextureCreate("", gfx.FORMAT_DEPTH24_STENCIL8, width, height, 0, true, false)
	gfx.TargetAttachStencil(alphaFullTarget, alphaFullStencilTexture)

	alphaTarget = gfx.TargetCreate(2, width, height, scale, true)
	var alpha0 TextureId = gfx.TextureCreate("", gfx.FORMAT_RGBA_16F, halfWidth, halfHeight, 0, true, false)
	gfx.TextureSamplerState(alpha0, gfx.g_linear0Wrap)
	gfx.TargetAttachColor(alphaTarget, alpha0, 0)
	var alpha1 TextureId = gfx.TextureCreate("", gfx.FORMAT_RGBA_16F, halfWidth, halfHeight, 0, true, false)
	gfx.TextureSamplerState(alpha1, gfx.g_linear0Wrap)
	gfx.TargetAttachColor(alphaTarget, alpha1, 1)
	var alphaStencilTexture TextureId = gfx.TextureCreate("", gfx.FORMAT_DEPTH24_STENCIL8, halfWidth, halfHeight, 0, true, false)
	gfx.TargetAttachStencil(alphaTarget, alphaStencilTexture)

	mergeTarget = gfx.TargetCreate(1, width, height, 1, true)
	var merge0 TextureId = gfx.TextureCreate("", gfx.FORMAT_R8_G8_B8_A8, width, height, 0, true, false)
	gfx.TextureSamplerState(merge0, gfx.g_nearest0Clamp)
	gfx.TargetAttachColor(mergeTarget, merge0, 0)
	var mergeStencilTexture TextureId = gfx.TextureCreate("", gfx.FORMAT_DEPTH24_STENCIL8, width, height, 0, true, false)
	gfx.TargetAttachStencil(mergeTarget, mergeStencilTexture)

	skyMesh = gfx.MeshCreate(gfx.TRIANGLES, gfx.UNSIGNED_SHORT, 36, gfx.g_vertexLayout, 24);
	gfx.MeshBegin(skyMesh)
	gfx.MeshAppendBox(skyMesh, false, true,
		v3.ZERO,
		v3.make(5000.0, 0.0, 0.0), v3.make(0.0, 5000.0, 0.0), v3.make(0.0, 0.0, 5000.0),
		v4.ONE)
	gfx.MeshEnd(skyMesh)

	dollarMesh = gfx.MeshCreate(gfx.TRIANGLES, gfx.UNSIGNED_SHORT, 8192 * 3, gfx.g_vertexLayout, 8192 * 3)
	groundMesh = gfx.MeshCreate(gfx.TRIANGLES, gfx.UNSIGNED_SHORT, 6 * groundWidth * groundHeight, gfx.g_vertexLayout, 6 * groundWidth * groundHeight)
	gfx.MeshBegin(groundMesh)
	gfx.MeshAppendPlane(groundMesh, false, true,
		v3.ZERO,
		v3.make(groundRight, 0.0, 0.0),
		v3.GREEN,
		v3.make(0.0, 0.0, groundBack),
		groundWidth, groundHeight,
		v4.make(0.0, 0.0, 10.0, 10.0),
		v4.ONE)
	gfx.MeshEnd(groundMesh)
	phxGround0 = phx.AddObject(phx.TYPE_PLANE, TAG_GROUND, -1,
		phx.STATE_ACTIVE,// | phx.STATE_DEBUG | phx.STATE_DEBUG_WIRE,
		v3.make(0.0, worldPosY, 0.0), v3.ZERO, v3.ZERO,
		v3.make(groundRight, 0.0, 0.0), v3.GREEN, v3.make(0.0, 0.0, groundBack),
		0.0, 1.0, v4.make(0.0, 1.0, 0.0, 0.0), v4.ONE)
	phx.SetObjectRotation(phxGround0, v4.make(0.0, 0.0, 1.0, 0.2))
	phxGround1 = phx.AddObject(phx.TYPE_PLANE, TAG_GROUND, -1,
		phx.STATE_ACTIVE,// | phx.STATE_DEBUG | phx.STATE_DEBUG_WIRE,
		v3.make(-100.0, 2.0 * worldPosY, 0.0), v3.ZERO, v3.ZERO,
		v3.make(groundRight, 0.0, 0.0), v3.GREEN, v3.make(0.0, 0.0, groundBack),
		0.0, 1.0, v4.make(0.0, 1.0, 0.0, 0.0), v4.ONE)

	smokeTexture = gfx.TextureCreate(sprintf("%s/textures/smoke.png", app.DataDir()), gfx.FORMAT_R8_G8_B8_A8, 0, 0, -32, false, false)
	dollar = gfx.TextureCreate(sprintf("%s/textures/skynote.png", app.DataDir()), gfx.FORMAT_R8_G8_B8_A8, 0, 0, -32, false, false)
	texture = gfx.TextureCreate(sprintf("%s/textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png", app.DataDir()), gfx.FORMAT_R8_G8_B8_A8, 0, 0, -32, false, false)


    characterCreate("skylight/synth", 0.1,"mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, v1.PI))
    characterCreate("skylight/metalic", 0.1,"mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))
    characterCreate("skylight/bw", 0.1, "mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))
    characterCreate("skylight/megafee", 0.1,"mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))
    characterCreate("skylight/bugd", 0.1,"mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))
    characterCreate("skylight/npc", 0.1,"mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))
    characterCreate("skylight/darkz", 6.0,"mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))
    characterCreate("skylight/dmux", 5.5,"mixamorig:Hips_01", "mixamorig:Spine_02", "mixamorig:RightShoulder_012", "mixamorig:RightHand_00", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))
    characterCreate("skylight/bouffet", 5.0,"mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))
    characterCreate("skylight/drump", 5.0,"mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))
    characterCreate("skylight/gutsin", 5.0,"mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014", q4.from_axis_angle(0.0, 1.0, 0.0, 0.0))

    levelCreate("skylight/skyminer/high", 2, "skylight/skyminer/collision", 4)
    //levelCreate("skylight/skyantenna/high", 2, "skylight/skyantenna/collision", 4)
    //levelCreate("glTF-Sample-Models/Sponza/glTF", 2, "glTF-Sample-Models/Sponza/glTF", 4)

    //skyCreate("doge2")
    skyCreate("footprint_court")
    /*skyCreate("helipad")
    skyCreate("papermill")
    skyCreate("pisa")
    if isModeDebug {
        skyCreate("field")
        skyCreate("ennis")
        skyCreate("studio_grey")
        skyCreate("studio_red_green")
    }*/

    brdf = gfx.TextureCreate(sprintf("%s/textures/environments/brdf2.png", app.DataDir()), gfx.FORMAT_R8_G8_B8_A8, 0, 0, 0, false, false)


    skyminerModel = loadModel("skylight/skyminer/low", "skyminer_low_test.gltf", gfx.MODEL_GEOMETRY)

    camera = gam.CameraCreate()
    frustum = gfx.FrustumCreate()
	/*gam.CameraSetProjection(camera, 0.5, 10000.0, 0.5, gfx.gfx_viewportSize.x, gfx.gfx_viewportSize.y, true)
	gam.CameraSetPosition(camera, v3.make(0.0, worldPosY + 1.0, 0.0), true)
	gam.CameraSetYawPitch(camera, 0.0, 0.0, true)*/
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func loadLevel()() {
    if isModeLight == false {
        playerCount = 1
    }
    var levelCount i32 = len(levels)
    currentLevel = i32.rand(0, levelCount) % levelCount
    if levels[currentLevel].loaded == false {
        if isModeLight == false {
            var t0 i64

            t0 = time.UnixNano()
            var levelOctree gfx.OctreeId = gfx.OctreeLoad(levels[currentLevel].gfxName, false)
            printf("Graphics octree loaded in %f seconds\n", fps.NanoToSecond(time.UnixNano() - t0))
            panicIf(gfx.OctreeIsValid(levelOctree) == false, "failed to load graphics octree")
            levels[currentLevel].gfxOctree = levelOctree

            t0 = time.UnixNano()
		    var phxOctree gfx.OctreeId = gfx.OctreeLoad(levels[currentLevel].phxName, false)
            printf("Collision octree loaded in %f seconds\n", fps.NanoToSecond(time.UnixNano() - t0))
            panicIf(gfx.OctreeIsValid(phxOctree) == false, "failed to load physics octree")
            levels[currentLevel].phxOctree = phxOctree
            levels[currentLevel].physic = phx.AddOctree(TAG_LEVEL, -1, phx.STATE_DEBUG | phx.STATE_DEBUG_WIRE | phx.STATE_DEBUG_COLOR, phxOctree)
        }
        levels[currentLevel].loaded = true

        var phxTri0 i32 = phx.AddTriangle(TAG_GROUND, -1, phx.STATE_DEBUG | phx.STATE_DEBUG_COLOR | phx.STATE_ACTIVE,
                v3.make(-500.0, worldPosY, 0.0),
                v3.make(0.0, worldPosY + 20.0, 0.0),
                v3.make(-500.0, worldPosY + 20.0, -500.0),
                v4.GREEN)

        var phxTri1 i32 = phx.AddTriangle(TAG_GROUND, -1, phx.STATE_DEBUG | phx.STATE_DEBUG_COLOR | phx.STATE_ACTIVE,
                v3.make(0.0, worldPosY + 5.0, 0.0),
                v3.make(0.0, worldPosY + 1.0, -500.0),
                v3.make(-500.0, worldPosY + 5.0, -500.0),
                v4.BLUE)

        var phxTri2 i32 = phx.AddTriangle(TAG_GROUND, -1, phx.STATE_DEBUG | phx.STATE_DEBUG_COLOR | phx.STATE_ACTIVE,
                v3.make(0.0, worldPosY + 5.0, 0.0),
                v3.make(50.0, worldPosY - 20.0, 0.0),
                v3.make(0.0, worldPosY + 1.0, -500.0),
                v4.RED)

    }

    var characterCount i32 = len(characters)
    players = resize(players, 0)
    for i := 0; i < playerCount; i++ {
        var r i32 = i32.rand(0, characterCount) % characterCount
        playerCreate(i, r)
    }
	currentPlayer = 0

    var skyCount i32 = len(skies)
    currentSky = i32.rand(0, skyCount) % skyCount
    for i := 0; i < skyCount; i++ {
        if (i == currentSky || isModeDebug == true) && skies[i].loaded == false {
            var sky Sky
            sky.specular = gfx.TextureCreateCube(sprintf("%s/textures/environments/%s/specular/specular_.hdr", app.DataDir(), skies[i].name), gfx.FORMAT_RGB_16F, 0, 0, 32, false)
	        sky.diffuse = gfx.TextureCreateCube(sprintf("%s/textures/environments/%s/diffuse/diffuse_.hdr", app.DataDir(), skies[i].name), gfx.FORMAT_RGB_16F, 0, 0, 0, false)
            sky.loaded = true
            skies[i] = sky
        }
    }


	gam.CameraSetProjection(camera, 0.5, 10000.0, 0.5, gfx.gfx_viewportSize.x, gfx.gfx_viewportSize.y, true)
	gam.CameraSetPosition(camera, v3.make(0.0, worldPosY + 1.0, 0.0), true)
	gam.CameraSetYawPitch(camera, 0.0, 0.0, true)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func main()() {
    //StartCPUProfile("skylight_run", 100)
    app.SetParseCallback("main", "gameOnParse")
	app.SetStartCallback("main", "gameOnStart")
	if app.Run("skylight", 1024, 768, 60, "", gfx.GL_VERSION_NONE, 2U) {
	    gfx.MeshUnlock(skyMesh)
	    gfx.MeshUnlock(groundMesh)
	    //gam.Destroy()//ISSUE : can't call gam.Destroy()
    }
	//StopCPUProfile("skylight_run")
}

