package gfx

import "mat"

var OCTREE_GRAPHICS i32 = 1
var OCTREE_COLLISIONS i32 = 2

// Globals ...
var g_octrees []Octree
var g_octreeCells []mat.v3

// OctreeCell ...
type OctreeCell struct {
    index i32
    level i32
    center mat.v3
    min mat.v3
    max mat.v3
    size mat.v3
    transparents []i32
    opaques []i32
    transparentTriangleCount i32
    opaqueTriangleCount i32
    triangleCount i32
    transparentPrimitives []i32
    opaquePrimitives []i32
    positions []f32
    normals []f32
    planesOrigin []mat.v3
    planesNormal []mat.v3
    points []mat.v3
    children [8] i32
}

// OctreeId ...
type OctreeId struct {
    octree i32
}

// InvalidOctree ...
func InvalidOctree() (out OctreeId) {
    out.octree = -1
}

// OctreeIsValid ...
func OctreeIsValid(id OctreeId) (out bool) {
    out = id.octree >= 0 && id.octree < len(g_octrees)
}

// Octree ...
type Octree struct {
    // runtime
    debugMesh MeshId
    visibles []i32
    visibleCount i32
    offsets []i32
    tmp []i32
    visiblePrimitives []i32
    opaqueBuckets []PrimitiveBucket
    transparentBuckets []PrimitiveBucket

    // serialized
    center mat.v3
    size mat.v3
    min mat.v3
    max mat.v3
    maxLevel i32
    world mat.m44
    transforms []mat.m44
    cells []OctreeCell
    mins []mat.v3
    maxs []mat.v3
    primitives []Primitive
}

func octreeCreate(debug bool) (out OctreeId) {
    var octree Octree
    octree.maxLevel = -1
    if debug {
        octree.debugMesh = MeshCreate(LINES, UNSIGNED_SHORT, 10 * 8192 * 3, g_vertexLayout, 10 * 8192 * 3)
    } else {
        octree.debugMesh = InvalidMesh()
    }
    out.octree = len(g_octrees)
    g_octrees = append(g_octrees, octree)
}

var scratchF32 []f32
var scratchI32 []i32

func readSTR(handle i32) (out str) {
    var success bool
    out, success = os.ReadStr(handle)
    panicIf(success == false, "failed to read str")
}

func readI64(handle i32) (out i64) {
    var success bool
    out, success = os.ReadI64(handle)
    panicIf(success == false, "failed to read i64")
}

func readUI64(handle i32) (out ui64) {
    var success bool
    out, success = os.ReadUI64(handle)
    panicIf(success == false, "failed to read ui64")
}

func readF32(handle i32) (out f32) {
    var success bool
    out, success = os.ReadF32(handle)
    panicIf(success == false, "failed to read f32")
}

func readI32(handle i32) (out i32) {
    var success bool
    out, success = os.ReadI32(handle)
    panicIf(success == false, "failed to read i32")
}

func readBOOL(handle i32) (out bool) {
    var success bool
    out, success = os.ReadBOOL(handle)
    panicIf(success == false, "failed to read bool")
}

func readF32Slice(handle i32, value []f32) (out []f32) {
    var success bool
    var count ui64 = readUI64(handle)
    if count > 0UL {
        out, success = os.ReadF32Slice(handle, value, count)
        panicIf(success == false, "failed to read []f32")
    }
}

func readI32Slice(handle i32, value []i32) (out []i32) {
    var success bool
    var count ui64 = readUI64(handle)
    if count > 0UL {
        out, success = os.ReadI32Slice(handle, value, count)
        panicIf(success == false, "failed to read []i32")
    }
}

func readUI8Slice(handle i32, value []ui8) (out []ui8) {
    var success bool
    var count ui64 = readUI64(handle)
    if count > 0UL {
        out, success = os.ReadUI8Slice(handle, value, count)
        panicIf(success == false, "failed to read []ui8")
    }
}

func writeSTR(handle i32, value str) {
    var success bool = os.WriteStr(handle, value)
    panicIf(success == false, "failed to write str")
}

func writeI64(handle i32, value i64) {
    var success bool = os.WriteI64(handle, value)
    panicIf(success == false, "failed to write i64")
}

func writeUI64(handle i32, value ui64) {
    var success bool = os.WriteUI64(handle, value)
    panicIf(success == false, "failed to write ui64")
}

func writeF32(handle i32, value f32) {
    var success bool = os.WriteF32(handle, value)
    panicIf(success == false, "failed to write f32")
}

func writeI32(handle i32, value i32) {
    var success bool = os.WriteI32(handle, value)
    panicIf(success == false, "failed to write i32")
}

func writeBOOL(handle i32, value bool) {
    var success bool = os.WriteBOOL(handle, value)
    panicIf(success == false, "failed to write bool")
}

func writeF32Slice(handle i32, value []f32) {
    var count ui64 = i32.ui64(len(value))
    writeUI64(handle, count)
    if count > 0UL {
        var success bool = os.WriteF32Slice(handle, value)
        panicIf(success == false, "failed to write []f32")
    }
}

func writeI32Slice(handle i32, value []i32) {
    var count ui64 = i32.ui64(len(value))
    writeUI64(handle, count)
    if count > 0UL {
        var success bool = os.WriteI32Slice(handle, value)
        panicIf(success == false, "failed to write []i32")
    }
}

func writeUI8Slice(handle i32, value []ui8) {
    var count ui64 = i32.ui64(len(value))
    writeUI64(handle, count)
    if count > 0UL {
        var success bool = os.WriteUI8Slice(handle, value)
        panicIf(success == false, "failed to write []ui8")
    }
}

func readV3F(handle i32) (out v3) {
    scratchF32 = resize(scratchF32, 0)
    var success bool
    scratchF32, success = os.ReadF32Slice(handle, scratchF32, 3UL)
    panicIf(success == false, "failed to read v3f")
    out.x = scratchF32[0]
    out.y = scratchF32[1]
    out.z = scratchF32[2]

}

func readV4F(handle i32) (out v4) {
    scratchF32 = resize(scratchF32, 0)
    var success bool
    scratchF32, success = os.ReadF32Slice(handle, scratchF32, 4UL)
    panicIf(success == false, "failed to read v4f")
    out.x = scratchF32[0]
    out.y = scratchF32[1]
    out.z = scratchF32[2]
    out.w = scratchF32[3]
}

func readM44F(handle i32) (out m44) {
    scratchF32 = resize(scratchF32, 0)
    var success bool
    scratchF32, success = os.ReadF32Slice(handle, scratchF32, 16UL)
    panicIf(success == false, "failed to read m44f")
    out.v00 = scratchF32[0]
    out.v01 = scratchF32[1]
    out.v02 = scratchF32[2]
    out.v03 = scratchF32[3]

    out.v10 = scratchF32[4]
    out.v11 = scratchF32[5]
    out.v12 = scratchF32[6]
    out.v13 = scratchF32[7]

    out.v20 = scratchF32[8]
    out.v21 = scratchF32[9]
    out.v22 = scratchF32[10]
    out.v23 = scratchF32[11]
    
    out.v30 = scratchF32[12]
    out.v31 = scratchF32[13]
    out.v32 = scratchF32[14]
    out.v33 = scratchF32[15]
}

func writeV3F(handle i32, value v3) {
    scratchF32 = resize(scratchF32, 3)
    scratchF32[0] = value.x
    scratchF32[1] = value.y
    scratchF32[2] = value.z
    var success bool = os.WriteF32Slice(handle, scratchF32)
    panicIf(success == false, "failed to write v3f")
}

func writeV4F(handle i32, value v4) {
    scratchF32 = resize(scratchF32, 4)
    scratchF32[0] = value.x
    scratchF32[1] = value.y
    scratchF32[2] = value.z
    scratchF32[3] = value.w
    var success bool = os.WriteF32Slice(handle, scratchF32)
    panicIf(success == false, "failed to write v4f")
}

func writeM44F(handle i32, value m44) {
    scratchF32 = resize(scratchF32, 16)
    scratchF32[0] = value.v00
    scratchF32[1] = value.v01
    scratchF32[2] = value.v02
    scratchF32[3] = value.v03

    scratchF32[4] = value.v10
    scratchF32[5] = value.v11
    scratchF32[6] = value.v12
    scratchF32[7] = value.v13

    scratchF32[8] = value.v20
    scratchF32[9] = value.v21
    scratchF32[10] = value.v22
    scratchF32[11] = value.v23

    scratchF32[12] = value.v30
    scratchF32[13] = value.v31
    scratchF32[14] = value.v32
    scratchF32[15] = value.v33
    var success bool = os.WriteF32Slice(handle, scratchF32)
    panicIf(success == false, "failed to write m44f")
}

func readV3FSlice(handle i32, value[]v3) (out []v3) { // TODO : issue resizing []v3
    out = value
    scratchF32 = readF32Slice(handle, scratchF32)
    var count i32 = len(scratchF32)
    panicIf((count%3) != 0, "invalid []v3")
    count = count/3
    out = resize(out, 0)
    for i := 0; i < count; i++ {
    var v v3
        var offset i32 = i * 3
        v.x = scratchF32[offset]
        v.y = scratchF32[offset+1]
        v.z = scratchF32[offset+2]
        out = append(out, v)
    }
}

func writeV3FSlice(handle i32, value []v3) {
    var count i32 = len(value)
    scratchF32 = resize(scratchF32, count * 3)
    for i := 0; i < count; i++ {
        var offset i32 = i * 3
        scratchF32[offset] = value[i].x
        scratchF32[offset+1] = value[i].y
        scratchF32[offset+2] = value[i].z
    }
    writeF32Slice(handle, scratchF32)
}

func readM44FSlice(handle i32, value[]m44) (out []m44) { // TODO : issue resizing []m44
    out = value
    scratchF32 = readF32Slice(handle, scratchF32)
    var count i32 = len(scratchF32)
    panicIf((count%16) != 0, "invalid []m44")
    count = count / 16
    out = resize(out, 0)
    for i := 0; i < count; i++ {
        var m m44
        var offset i32 = i * 16
        m.v00 = scratchF32[offset]
        m.v01 = scratchF32[offset+1]
        m.v02 = scratchF32[offset+2]
        m.v03 = scratchF32[offset+3]

        m.v10 = scratchF32[offset+4]
        m.v11 = scratchF32[offset+5]
        m.v12 = scratchF32[offset+6]
        m.v13 = scratchF32[offset+7]

        m.v20 = scratchF32[offset+8]
        m.v21 = scratchF32[offset+9]
        m.v22 = scratchF32[offset+10]
        m.v23 = scratchF32[offset+11]

        m.v30 = scratchF32[offset+12]
        m.v31 = scratchF32[offset+13]
        m.v32 = scratchF32[offset+14]
        m.v33 = scratchF32[offset+15]
        out = append(out, m)
    }

}

func writeM44FSlice(handle i32, value []m44) {
    var count i32 = len(value)
    scratchF32 = resize(scratchF32, count * 16)
    for i := 0; i < count; i++ {
        var offset i32 = i * 16
        scratchF32[offset] = value[i].v00
        scratchF32[offset+1] = value[i].v01
        scratchF32[offset+2] = value[i].v02
        scratchF32[offset+3] = value[i].v03

        scratchF32[offset+4] = value[i].v10
        scratchF32[offset+5] = value[i].v11
        scratchF32[offset+6] = value[i].v12
        scratchF32[offset+7] = value[i].v13

        scratchF32[offset+8] = value[i].v20
        scratchF32[offset+9] = value[i].v21
        scratchF32[offset+10] = value[i].v22
        scratchF32[offset+11] = value[i].v23

        scratchF32[offset+12] = value[i].v30
        scratchF32[offset+13] = value[i].v31
        scratchF32[offset+14] = value[i].v32
        scratchF32[offset+15] = value[i].v33
    }
    writeF32Slice(handle, scratchF32)
}

func readOctreeCells(handle i32, value []OctreeCell) (out []OctreeCell) {
    out = value
    var count i32 = ui64.i32(readUI64(handle))
    out = resize(out, 0)
    var i ui64
    for i := 0; i < count; i++ {
        var oc OctreeCell
        oc.index = readI32(handle)
        oc.level = readI32(handle)     
        oc.center = readV3F(handle)
        oc.min = readV3F(handle)
        oc.max = readV3F(handle)
        oc.size = readV3F(handle)
        oc.transparents = readI32Slice(handle, oc.transparents)
        oc.opaques = readI32Slice(handle, oc.opaques)
        oc.transparentTriangleCount = readI32(handle)
        oc.opaqueTriangleCount = readI32(handle)
        oc.triangleCount = readI32(handle)
        oc.transparentPrimitives = readI32Slice(handle, oc.transparentPrimitives)
        oc.opaquePrimitives = readI32Slice(handle, oc.opaquePrimitives)
        oc.positions = readF32Slice(handle, oc.positions)
        oc.normals = readF32Slice(handle, oc.normals)
        oc.planesOrigin = readV3FSlice(handle, oc.planesOrigin)
        oc.planesNormal = readV3FSlice(handle, oc.planesNormal)
        oc.points = readV3FSlice(handle, oc.points)
        for c := 0; c < 8; c++ {
            oc.children[c] = readI32(handle)
        }
        out = append(out, oc)
    }
}

func writeOctreeCells(handle i32, value []OctreeCell, options i32) {
    var count i32 = len(value)
    writeUI64(handle, i32.ui64(count))
    for i := 0; i < count; i++ {
        writeI32(handle, value[i].index)
        writeI32(handle, value[i].level)
        writeV3F(handle, value[i].center)
        writeV3F(handle, value[i].min)
        writeV3F(handle, value[i].max)
        writeV3F(handle, value[i].size)
        writeI32Slice(handle, value[i].transparents)
        writeI32Slice(handle, value[i].opaques)
        writeI32(handle, value[i].transparentTriangleCount)
        writeI32(handle, value[i].opaqueTriangleCount)
        writeI32(handle, value[i].triangleCount)
        writeI32Slice(handle, value[i].transparentPrimitives)
        writeI32Slice(handle, value[i].opaquePrimitives)

        if options == OCTREE_COLLISIONS {
            writeF32Slice(handle, value[i].positions)
            writeF32Slice(handle, value[i].normals)
            writeV3FSlice(handle, value[i].planesOrigin)
            writeV3FSlice(handle, value[i].planesNormal)
            writeV3FSlice(handle, value[i].points)
        } else {
            writeUI64(handle, 0UL)
            writeUI64(handle, 0UL)
            writeUI64(handle, 0UL)
            writeUI64(handle, 0UL)
            writeUI64(handle, 0UL)
        }
        for c := 0; c < 8; c++ {
            writeI32(handle, value[i].children[c])
        }
    }
}

func readEffect(handle i32) (out EffectId) {
    var key i64 = readI64(handle)
    out = TemplateInstanceFromKey(g_tfxPbr, key)
}

func writeEffect(handle i32, effect EffectId) {
    writeI64(handle, EffectGetKey(effect))
}

func readGLTFMaterial(handle i32) (out gltf.Material) {
    out.pbrMetallicRoughness.baseColorFactor = readV4F(handle)
    out.pbrMetallicRoughness.baseColorTexture.scale = readF32(handle)
    out.pbrMetallicRoughness.metallicFactor = readF32(handle)
    out.pbrMetallicRoughness.roughnessFactor = readF32(handle)
    out.pbrSpecularGlossiness.diffuseFactor = readV4F(handle)
    out.pbrSpecularGlossiness.diffuseTexture.scale = readF32(handle)
    out.pbrSpecularGlossiness.glossinessFactor = readF32(handle)
    out.pbrSpecularGlossiness.specularFactor = readV3F(handle)
    out.pbrSpecularGlossiness.specularGlossinessTexture.scale = readF32(handle)
    out.normalTexture.scale = readF32(handle)
    out.emissiveTexture.scale = readF32(handle)
    out.emissiveFactor = readV4F(handle)
    out.alphaMode = readI32(handle)
    out.doubleSided = readI32(handle)
}

func writeGLTFMaterial(handle i32, material gltf.Material) {
    writeV4F(handle, material.pbrMetallicRoughness.baseColorFactor)
    writeF32(handle, material.pbrMetallicRoughness.baseColorTexture.scale)
    writeF32(handle, material.pbrMetallicRoughness.metallicFactor)
    writeF32(handle, material.pbrMetallicRoughness.roughnessFactor)
    writeV4F(handle, material.pbrSpecularGlossiness.diffuseFactor)
    writeF32(handle, material.pbrSpecularGlossiness.diffuseTexture.scale)
    writeF32(handle, material.pbrSpecularGlossiness.glossinessFactor)
    writeV3F(handle, material.pbrSpecularGlossiness.specularFactor)
    writeF32(handle, material.pbrSpecularGlossiness.specularGlossinessTexture.scale)
    writeF32(handle, material.normalTexture.scale)
    writeF32(handle, material.emissiveTexture.scale)
    writeV4F(handle, material.emissiveFactor)
    writeI32(handle, material.alphaMode)
    writeI32(handle, material.doubleSided)
}

func readTexture(handle i32) (out TextureId) {
    out = InvalidTexture()
    var texturePath str = readSTR(handle)
    if len(texturePath) > 0 {
        out = TextureCreate(texturePath, FORMAT_R8_G8_B8_A8, 0, 0, -32, false, false)
    }
}

func writeTexture(handle i32, texture TextureId) {
    var texturePath str
    if IsValidTexture(texture) {
        texturePath = TextureGetPath(texture)
    }
    writeSTR(handle, texturePath)
}

func readPrimitives(handle i32, value []Primitive) (out []Primitive) {
    out = value
    var count i32 = ui64.i32(readUI64(handle))
    out = resize(out, 0)
    var i ui64
    for i := 0; i < count; i++ {
        var primitive Primitive
        primitive.effect = readEffect(handle)
        primitive.baseTexture = readTexture(handle)
        primitive.metalRoughTexture = readTexture(handle)
        primitive.emissiveTexture = readTexture(handle)
        primitive.normalTexture = readTexture(handle)
        primitive.occlusionTexture = readTexture(handle)

        primitive.gltfMaterial = readGLTFMaterial(handle)

        primitive.min = readV3F(handle)
        primitive.max = readV3F(handle)

        primitive.vertices = readUI8Slice(handle, primitive.vertices)
        primitive.indices = readUI8Slice(handle, primitive.indices)

        var attributes []VertexAttribute = primitive.attributes
        var attributeCount i32 = ui64.i32(readUI64(handle))
        for attributeIndex := 0; attributeIndex < attributeCount; attributeIndex++ {
            var attribute VertexAttribute
            attribute.componentCount = readI32(handle)
            attribute.componentType = readI32(handle)
            attribute.componentByteSize = readI32(handle)
            attribute.componentOffset = readI32(handle)
            attribute.byteOffset = readI32(handle)
            attribute.binding = readI32(handle)
            attributes = append(attributes, attribute)
        }
        primitive.attributes = attributes

        primitive.indexByteStride = readI32(handle)
        primitive.vertexByteStride = readI32(handle)
        primitive.useSkin = readI32(handle)
        primitive.usePosition = readBOOL(handle)
        primitive.useNormal = readBOOL(handle)
        primitive.useColor = readBOOL(handle)
        primitive.useTexcoord = readBOOL(handle)
        primitive.useTangent = readBOOL(handle)
        primitive.useWeight = readBOOL(handle)
        primitive.useJoint = readBOOL(handle)

        var indexType i32 = ui64.i32(readUI64(handle))
        var primitiveType i32 = ui64.i32(readUI64(handle))
        var mesh MeshId = InvalidMesh()
        var vertexCount i32 = len(primitive.vertices)
        var indexCount i32 = len(primitive.indices)
        if (vertexCount > 0 && indexCount > 0) &&
           ((indexType == gl.UNSIGNED_SHORT) || (indexType == gl.UNSIGNED_INT)) &&
           ((primitiveType == gl.TRIANGLES) || (primitiveType == gl.LINES)) {
            mesh = MeshCreate(primitiveType, indexType,
                len(primitive.indices) / primitive.indexByteStride,
            attributes, len(primitive.vertices) / primitive.vertexByteStride)

            MeshBegin(mesh)
            g_meshes[mesh.mesh].vertices = primitive.vertices
            g_meshes[mesh.mesh].indices = primitive.indices
            g_meshes[mesh.mesh].usePosition = primitive.usePosition
            g_meshes[mesh.mesh].useNormal = primitive.useNormal
            g_meshes[mesh.mesh].useColor = primitive.useColor
            g_meshes[mesh.mesh].useTexcoord = primitive.useTexcoord
            g_meshes[mesh.mesh].useTangent = primitive.useTangent
            g_meshes[mesh.mesh].useWeight = primitive.useWeight
            g_meshes[mesh.mesh].useJoint = primitive.useJoint
            g_meshes[mesh.mesh].min = primitive.min
            g_meshes[mesh.mesh].max = primitive.max
            MeshEnd(mesh)
        }

        primitive.mesh = mesh


        out = append(out, primitive)
    }
}

func writePrimitives(handle i32, value []Primitive, options i32) {
    var count i32 = len(value)
    writeUI64(handle, i32.ui64(count))
    for i := 0; i < count; i++ {
        writeEffect(handle, value[i].effect)
        writeTexture(handle, value[i].baseTexture)
        writeTexture(handle, value[i].metalRoughTexture)
        writeTexture(handle, value[i].emissiveTexture)
        writeTexture(handle, value[i].normalTexture)
        writeTexture(handle, value[i].occlusionTexture)

        writeGLTFMaterial(handle, value[i].gltfMaterial)

        writeV3F(handle, value[i].min)
        writeV3F(handle, value[i].max)

        if options == OCTREE_GRAPHICS {
            writeUI8Slice(handle, value[i].vertices)
            writeUI8Slice(handle, value[i].indices)
        } else {
            writeUI64(handle, 0UL)            
            writeUI64(handle, 0UL)
        }

        var attributes []VertexAttribute = value[i].attributes
        var attributeCount i32 = len(attributes)
        writeUI64(handle, i32.ui64(attributeCount))
        for attributeIndex := 0; attributeIndex < attributeCount; attributeIndex++ {
            writeI32(handle, attributes[attributeIndex].componentCount)
            writeI32(handle, attributes[attributeIndex].componentType)
            writeI32(handle, attributes[attributeIndex].componentByteSize)
            writeI32(handle, attributes[attributeIndex].componentOffset)
            writeI32(handle, attributes[attributeIndex].byteOffset)
            writeI32(handle, attributes[attributeIndex].binding)
        }

        writeI32(handle, value[i].indexByteStride)
        writeI32(handle, value[i].vertexByteStride)
        writeI32(handle, value[i].useSkin)
        writeBOOL(handle, value[i].usePosition)
        writeBOOL(handle, value[i].useNormal)
        writeBOOL(handle, value[i].useColor)
        writeBOOL(handle, value[i].useTexcoord)
        writeBOOL(handle, value[i].useTangent)
        writeBOOL(handle, value[i].useWeight)
        writeBOOL(handle, value[i].useJoint)

        var indexType ui64 = 0UL
        var primitiveType ui64 = 0UL
        var mesh MeshId = value[i].mesh
        if IsValidMesh(mesh) {
            indexType = i32.ui64(g_meshes[mesh.mesh].indexFormat)
            primitiveType = i32.ui64(g_meshes[mesh.mesh].primitive)
        }
        writeUI64(handle, indexType)
        writeUI64(handle, primitiveType)
    }
        //mesh MeshId            
}

func octreeLoad(id OctreeId) {
    var octreePrimitives []Primitive = g_octrees[id.octree].primitives
    var octreePrimitiveCount i32 = len(octreePrimitives)
    for primitiveIndex := 0; primitiveIndex < octreePrimitiveCount; primitiveIndex++ {
        var hash0 ui64
        var hash1 ui64
        hash0, hash1 = PrimitiveComputeHash(octreePrimitives[primitiveIndex])
        octreePrimitives[primitiveIndex].hash0 = hash0
        octreePrimitives[primitiveIndex].hash1 = hash1
    }
}

var fingerPrint ui64 = 383838383838UL
func OctreeLoad(path str, debug bool) (out OctreeId) {
    out = octreeCreate(debug)
    var octreeIndex i32 = out.octree
    var handle i32 = os.Open(path)
    if handle != -1 {
        g_octrees[octreeIndex].center = readV3F(handle)
        g_octrees[octreeIndex].size = readV3F(handle)
        g_octrees[octreeIndex].min = readV3F(handle)
        g_octrees[octreeIndex].max = readV3F(handle)
        g_octrees[octreeIndex].maxLevel = readI32(handle)
        g_octrees[octreeIndex].world = readM44F(handle)
        g_octrees[octreeIndex].transforms = readM44FSlice(handle, g_octrees[octreeIndex].transforms)
        g_octrees[octreeIndex].cells = readOctreeCells(handle, g_octrees[octreeIndex].cells)
        g_octrees[octreeIndex].mins = readV3FSlice(handle, g_octrees[octreeIndex].mins)
        g_octrees[octreeIndex].maxs = readV3FSlice(handle, g_octrees[octreeIndex].maxs)
        g_octrees[octreeIndex].primitives = readPrimitives(handle, g_octrees[octreeIndex].primitives)
        var fp ui64 = readUI64(handle)
        panicIf(fp != fingerPrint, "failed to OctreeLoad : invalid fingerPrint")
        var success bool = os.Close(handle)
        if success == false {
            out = InvalidOctree()
        }
    }

    octreeLoad(out)
}

func OctreeSave(id OctreeId, path str, options i32) (out bool) {
    var handle i32 = os.Create(path)
    if handle != -1 {
        writeV3F(handle, g_octrees[id.octree].center)
        writeV3F(handle, g_octrees[id.octree].size)
        writeV3F(handle, g_octrees[id.octree].min)
        writeV3F(handle, g_octrees[id.octree].max)
        writeI32(handle, g_octrees[id.octree].maxLevel)
        writeM44F(handle, g_octrees[id.octree].world)
        writeM44FSlice(handle, g_octrees[id.octree].transforms)
        writeOctreeCells(handle, g_octrees[id.octree].cells, options)
        writeV3FSlice(handle, g_octrees[id.octree].mins)
        writeV3FSlice(handle, g_octrees[id.octree].maxs)
        writePrimitives(handle, g_octrees[id.octree].primitives, options)
        writeUI64(handle, fingerPrint)
        out = os.Close(handle)
    }
}

func neqUI8Slice(left []ui8, right []ui8) (out bool) {
    out = true
    var leftCount i32 = len(left)
    var rightCount i32 = len(right)

    if leftCount == rightCount {
        out = false
        for i := 0; i < leftCount; i++ {
            if left[i] != right[i] {
                i = leftCount
                out = true
            }
        }
    }
}

func neqI32Slice(left []i32, right []i32) (out bool) {
    out = true
    var leftCount i32 = len(left)
    var rightCount i32 = len(right)

    if leftCount == rightCount {
        out = false
        for i := 0; i < leftCount; i++ {
            if left[i] != right[i] {
                i = leftCount
                out = true
            }
        }
    }
}

func neqF32Slice(left []f32, right []f32) (out bool) {
    out = true
    var leftCount i32 = len(left)
    var rightCount i32 = len(right)

    if leftCount == rightCount {
        out = false
        for i := 0; i < leftCount; i++ {
            if left[i] != right[i] {
                out = true
                i = leftCount
            }
        }
    }
}

func neqV3FSlice(left []v3, right []v3) (out bool) {
    out = true
    var leftCount i32 = len(left)
    var rightCount i32 = len(right)

    if leftCount == rightCount {
        out = false
        for i := 0; i < leftCount; i++ {
            if v3.nequ(left[i], right[i]) {
                out = true
                i = leftCount
            }
        }
    }
}


func OctreeAssertEquals(left OctreeId, right OctreeId, options i32) {
    panicIf(v3.nequ(g_octrees[left.octree].center, g_octrees[right.octree].center), "center")
    panicIf(v3.nequ(g_octrees[left.octree].size, g_octrees[right.octree].size), "size")
    panicIf(v3.nequ(g_octrees[left.octree].min, g_octrees[right.octree].min), "min")
    panicIf(v3.nequ(g_octrees[left.octree].max, g_octrees[right.octree].max), "max")
    panicIf((g_octrees[left.octree].maxLevel != g_octrees[right.octree].maxLevel), "maxLevel")
    panicIf(m44.nequ(g_octrees[left.octree].world, g_octrees[right.octree].world), "world")

    var leftTX []m44 = g_octrees[left.octree].transforms
    var rightTX []m44 = g_octrees[right.octree].transforms

    var leftTxCount i32 = len(leftTX)
    var rightTxCount i32 = len(rightTX)

    panicIf(leftTxCount != rightTxCount, sprintf("transform count : %d vs %d", leftTxCount, rightTxCount))
    for i := 0; i < leftTxCount; i++ {
        panicIf(m44.nequ(leftTX[i], rightTX[i]), "transforms")
    }

    var leftCells []OctreeCell = g_octrees[left.octree].cells
    var rightCells []OctreeCell = g_octrees[right.octree].cells

    var leftCellCount i32 = len(leftCells)
    var rightCellCount i32 = len(rightCells)

    panicIf(leftCellCount != rightCellCount, sprintf("cell count : %d vs %d", leftCellCount, rightCellCount))
    for i := 0; i < leftCellCount; i++ {
        var lc OctreeCell = leftCells[i]
        var rc OctreeCell = rightCells[i]

        panicIf(lc.index != rc.index, "index")
        panicIf(lc.level != rc.level, "level")
        panicIf(v3.nequ(lc.center, rc.center), "center")
        panicIf(v3.nequ(lc.min, rc.min), "min")
        panicIf(v3.nequ(lc.max, rc.max), "max")
        panicIf(v3.nequ(lc.size, rc.size), "size")

        panicIf(neqI32Slice(lc.transparents, rc.transparents), "transparents")
        panicIf(neqI32Slice(lc.opaques, rc.opaques), "opaques")
        panicIf(lc.transparentTriangleCount != rc.transparentTriangleCount, "transparentTriangleCount")
        panicIf(lc.opaqueTriangleCount != rc.opaqueTriangleCount, "opaqueTriangleCount")
        panicIf(lc.triangleCount != rc.triangleCount, "triangleCount")
        panicIf(neqI32Slice(lc.transparentPrimitives, rc.transparentPrimitives), "transparentPrimitives")
        panicIf(neqI32Slice(lc.opaquePrimitives, rc.opaquePrimitives), "opaquePrimitives")

        if options == OCTREE_COLLISIONS {
            panicIf(neqF32Slice(lc.positions, rc.positions), "positions")
            panicIf(neqF32Slice(lc.normals, rc.normals), "normals")
            panicIf(neqV3FSlice(lc.planesOrigin, rc.planesOrigin), "planesOrigin")
            panicIf(neqV3FSlice(lc.planesNormal, rc.planesNormal), "planesNormal")
            panicIf(neqV3FSlice(lc.points, rc.points), "points")
        }

        for c := 0; c < 8; c++ {
            panicIf(lc.children[c] != rc.children[c], "children")
        }
    }

    var leftPrimitives []Primitive = g_octrees[left.octree].primitives
    var rightPrimitives []Primitive = g_octrees[right.octree].primitives

    var leftPrimitiveCount i32 = len(leftPrimitives)
    var rightPrimitiveCount i32 = len(rightPrimitives)

    panicIf(leftPrimitiveCount != rightPrimitiveCount, sprintf("primitive count : %d vs %d", leftPrimitiveCount, rightPrimitiveCount))
    for i := 0; i < leftPrimitiveCount; i++ {
        var lp Primitive = leftPrimitives[i]
        var rp Primitive = rightPrimitives[i]

        panicIf(lp.effect.effect != rp.effect.effect, "effect")
        panicIf(lp.baseTexture.texture != rp.baseTexture.texture, "baseTexture")
        panicIf(lp.metalRoughTexture.texture != rp.metalRoughTexture.texture, "metalRoughTexture")
        panicIf(lp.emissiveTexture.texture != rp.emissiveTexture.texture, "emissiveTexture")
        panicIf(lp.normalTexture.texture != rp.normalTexture.texture, "normalTexture")
        panicIf(lp.occlusionTexture.texture != rp.occlusionTexture.texture, "occlusionTexture")


        var lm gltf.Material = lp.gltfMaterial
        var rm gltf.Material = rp.gltfMaterial
        panicIf(v4.nequ(lm.pbrMetallicRoughness.baseColorFactor, rm.pbrMetallicRoughness.baseColorFactor), "baseColorFactor")
        panicIf(lm.pbrMetallicRoughness.baseColorTexture.scale != rm.pbrMetallicRoughness.baseColorTexture.scale, "baseColorTexture.scale")
        panicIf(lm.pbrMetallicRoughness.metallicFactor != rm.pbrMetallicRoughness.metallicFactor, "metallicFactor")
        panicIf(lm.pbrMetallicRoughness.roughnessFactor != rm.pbrMetallicRoughness.roughnessFactor, "roughnessFactor")
        panicIf(v4.nequ(lm.pbrSpecularGlossiness.diffuseFactor, rm.pbrSpecularGlossiness.diffuseFactor), "diffuseFactor")
        panicIf(lm.pbrSpecularGlossiness.diffuseTexture.scale != rm.pbrSpecularGlossiness.diffuseTexture.scale, "diffuseTexture.scale")
        panicIf(lm.pbrSpecularGlossiness.glossinessFactor != rm.pbrSpecularGlossiness.glossinessFactor, "glossinessFactor")
        panicIf(v3.nequ(lm.pbrSpecularGlossiness.specularFactor, rm.pbrSpecularGlossiness.specularFactor), "specularFactor")
        panicIf(lm.pbrSpecularGlossiness.specularGlossinessTexture.scale != rm.pbrSpecularGlossiness.specularGlossinessTexture.scale, "specularGlossinessTexture.scale")
        panicIf(lm.normalTexture.scale != rm.normalTexture.scale, "normalTexture.scale")
        panicIf(lm.emissiveTexture.scale != rm.emissiveTexture.scale, "emissiveTexture.scale")
        panicIf(v4.nequ(lm.emissiveFactor, rm.emissiveFactor), "emissiveFactor")
        panicIf(lm.alphaMode != rm.alphaMode, "alphaMode")
        panicIf(lm.doubleSided != rm.doubleSided, "doubleSided")

        panicIf(v3.nequ(lp.min, rp.min), "min")
        panicIf(v3.nequ(lp.max, rp.max), "max")

        if options == OCTREE_GRAPHICS {
            panicIf(neqUI8Slice(lp.vertices, rp.vertices), "vertices")
            panicIf(neqUI8Slice(lp.indices, rp.indices), "indices")
        }

        var leftAttributes []VertexAttribute = lp.attributes
        var rightAttributes []VertexAttribute = rp.attributes

        var leftAttributeCount i32 = len(leftAttributes)
        var rightAttributeCount i32 = len(rightAttributes)

        panicIf(leftAttributeCount != rightAttributeCount, "attributes")
        for attributeIndex := 0; attributeIndex < leftAttributeCount; attributeIndex++ {
            panicIf(leftAttributes[attributeIndex].componentCount != rightAttributes[attributeIndex].componentCount, "componentCount")
            panicIf(leftAttributes[attributeIndex].componentType != rightAttributes[attributeIndex].componentType, "componentCount")
            panicIf(leftAttributes[attributeIndex].componentByteSize != rightAttributes[attributeIndex].componentByteSize, "componentByteSize")
            panicIf(leftAttributes[attributeIndex].componentOffset != rightAttributes[attributeIndex].componentOffset, "componentOffset")
            panicIf(leftAttributes[attributeIndex].byteOffset != rightAttributes[attributeIndex].byteOffset, "byteOffset")
            panicIf(leftAttributes[attributeIndex].binding != rightAttributes[attributeIndex].binding, "binding")
        }

        panicIf(lp.indexByteStride != rp.indexByteStride, "indexByteStride")
        panicIf(lp.vertexByteStride != rp.vertexByteStride, "vertexByteStride")

        panicIf(lp.useSkin != rp.useSkin, "useSkin")
        panicIf(lp.usePosition != rp.usePosition, "usePosition")
        panicIf(lp.useNormal != rp.useNormal, "useNormal")
        panicIf(lp.useColor != rp.useColor, "useColor")
        panicIf(lp.useTexcoord != rp.useTexcoord, "useTexcoord")
        panicIf(lp.useTangent != rp.useTangent, "useTangent")
        panicIf(lp.useWeight != rp.useWeight, "useWeight")
        panicIf(lp.useJoint != rp.useJoint, "useJoint")

        if options == OCTREE_GRAPHICS {
            var leftMesh MeshId = lp.mesh
            var rightMesh MeshId = rp.mesh
            panicIf(IsValidMesh(leftMesh) != IsValidMesh(rightMesh), "mesh")

            if (IsValidMesh(leftMesh)) {
                panicIf(g_meshes[leftMesh.mesh].indexFormat != g_meshes[rightMesh.mesh].indexFormat, "indexType")
                panicIf(g_meshes[leftMesh.mesh].primitive != g_meshes[rightMesh.mesh].primitive, "primitiveType")
            }
        }
    }

    panicIf(neqV3FSlice(g_octrees[left.octree].mins, g_octrees[right.octree].mins), "mins")
    panicIf(neqV3FSlice(g_octrees[left.octree].maxs, g_octrees[right.octree].maxs), "maxs")
}

func OctreeDestroy(id OctreeId) {
    panicIfNot(OctreeIsValid(id), "invalid id")
}

// OctreeCreate ...
func OctreeCreate(model ModelId, world mat.m44, maxLevel i32, debug bool, options i32) (out OctreeId) {
    out = octreeCreate(debug)

    realTriangleCount = 0

    var min mat.v3 = ModelGetMin(model)
    var max mat.v3 = ModelGetMax(model)

    min = v3.transform_point(min, world)
    max = v3.transform_point(max, world)

    var newMin mat.v3 = v3.min(min, max)
    var newMax mat.v3 = v3.max(min, max)

    g_octrees[out.octree].size = v3.mulf(v3.sub(newMax, newMin), 0.5)
    g_octrees[out.octree].center = v3.add(newMin, g_octrees[out.octree].size)
    g_octrees[out.octree].min = newMin
    g_octrees[out.octree].max = newMax
    g_octrees[out.octree].maxLevel = maxLevel
    g_octrees[out.octree].world = world

    var totalCount i32 = resetOffsets(out)
    var cells []OctreeCell
    for i := 0; i <= totalCount; i++ {
        var cell OctreeCell
        cells = append(cells, cell)
    }
    g_octrees[out.octree].cells = cells
    g_octreeCells = append(g_octreeCells, v3.make( 1.0,  1.0,  1.0))
    g_octreeCells = append(g_octreeCells, v3.make( 1.0,  1.0, -1.0))
    g_octreeCells = append(g_octreeCells, v3.make( 1.0, -1.0,  1.0))
    g_octreeCells = append(g_octreeCells, v3.make( 1.0, -1.0, -1.0))
    g_octreeCells = append(g_octreeCells, v3.make(-1.0,  1.0,  1.0))
    g_octreeCells = append(g_octreeCells, v3.make(-1.0,  1.0, -1.0))
    g_octreeCells = append(g_octreeCells, v3.make(-1.0, -1.0,  1.0))
    g_octreeCells = append(g_octreeCells, v3.make(-1.0, -1.0, -1.0))

    var root i32 = octreeUpdateCells(out, 0, g_octrees[out.octree].center, g_octrees[out.octree].size)

    var modelTransforms []m44 = g_models[model.model].transforms
    var transformCount i32 = len(modelTransforms)
    var transforms []m44
    for i := 0; i < transformCount; i++ {
        transforms = append(transforms, m44.mulISSUE(modelTransforms[i], world))
    }
    g_octrees[out.octree].transforms = transforms

    var cellCount i32 = resetOffsets(out)
    for i := 0; i < cellCount; i++ {
        cells[i].transparentPrimitives = resize(cells[i].transparentPrimitives, 0)
        cells[i].opaquePrimitives = resize(cells[i].opaquePrimitives, 0)
    }
    var primitives [] Primitive = g_models[model.model].primitives

    var primitiveCount i32 = len(primitives)
    var mins []mat.v3 = g_octrees[out.octree].mins
    var maxs []mat.v3 = g_octrees[out.octree].maxs

    mins = resize(mins, 0)
    maxs = resize(maxs, 0)
    for i := 0; i < primitiveCount; i++ {
        var nodeIndex i32 = primitives[i].nodeIndex
        var transform mat.m44 = transforms[nodeIndex] // ISSUE : can't use transforms[primitives[i].nodeIndex]

        var primMin mat.v3 = v3.transform_point(primitives[i].min, transform)
        var primMax mat.v3 = v3.transform_point(primitives[i].max, transform)

        var newPrimMin mat.v3 = v3.min(primMin, primMax)
        var newPrimMax mat.v3 = v3.max(primMin, primMax)

        mins = append(mins, newPrimMin)
        maxs = append(maxs, newPrimMax)

        //mins = append(mins, v3.min(newMin, newMax))
        //maxs = append(maxs, v3.max(newMin, newMax))
    }

    g_octrees[out.octree].mins = mins
    g_octrees[out.octree].maxs = maxs

    octreeSplitModel(out, model, 0, g_models[model.model].opaqueMeshes, g_models[model.model].transparentMeshes)

    var asset AssetId = g_models[model.model].asset
    for i := 0; i < cellCount; i++ {
       if i >= 0 {//== 54 || i == 6 {
        cells[i].opaques = octreeSplitMeshes(out, cells[i].opaquePrimitives,
            asset, primitives, transforms, cells, i, cells[i].opaques, options)
        cells[i].transparents = octreeSplitMeshes(out, cells[i].transparentPrimitives,
            asset, primitives, transforms, cells, i, cells[i].transparents, options)
        var opcell []Primitive = g_octrees[out.octree].primitives
        var opaqueTriCount i32 = computeTriangleCount(opcell, cells[i].opaques)
        var transparentTriCount i32 = computeTriangleCount(opcell, cells[i].transparents)
        printf("Splitting cell %d/%d... : Opaque %d + Transparent %d = %d \n", i, cellCount, opaqueTriCount, transparentTriCount, opaqueTriCount + transparentTriCount)
        var positions []f32 = cells[i].positions
        var positionCount i32 = len(positions)
        var triangleCount i32 = positionCount / (3 * 3)
        var normals []f32 = cells[i].normals
        if options == OCTREE_COLLISIONS {
            normals = resize(normals, 0)
            for t := 0; t < triangleCount; t++ {
                var toffset i32 = t*9
                var t0 mat.v3 = v3.make(positions[toffset+0], positions[toffset+1], positions[toffset+2])
                var t1 mat.v3 = v3.make(positions[toffset+3], positions[toffset+4], positions[toffset+5])
                var t2 mat.v3 = v3.make(positions[toffset+6], positions[toffset+7], positions[toffset+8])

                var t01 mat.v3 = v3.sub(t1, t0)
                var t02 mat.v3 = v3.sub(t2, t0)
                var t012 mat.v3 = v3.cross(t01, t02)
                var len012 f32 = v3.length(t012)
                var normal v3 = v3.ZERO
                if len012 > 0.0 {
                    normal = v3.divf(t012, len012)
                }

                normals = append(normals, normal.x)
                normals = append(normals, normal.y)
                normals = append(normals, normal.z)
            }
        }
        cells[i].normals = normals
        cells[i].triangleCount = triangleCount
        cells[i].opaqueTriangleCount = opaqueTriCount
        cells[i].transparentTriangleCount = transparentTriCount
        panicIf((triangleCount != (opaqueTriCount+transparentTriCount)),
               sprintf("TRI %d, SUM %d, OPAQUE %d, ALPHA %d, POS %d, MOD %d", triangleCount,
                   opaqueTriCount+transparentTriCount,
                   opaqueTriCount, transparentTriCount, positionCount, positionCount%9))
       panicIf(((positionCount%9) != 0), sprintf("POS %d, MOD %d", positionCount, positionCount%9))
    }
    }

    octreeLoad(out)
}

func resetOffsets(id OctreeId) (count i32) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    var totalCount i32
    var layerCount i32 = 1
    var maxLevel i32 = g_octrees[id.octree].maxLevel
    var offsets []i32 = g_octrees[id.octree].offsets
    offsets = resize(offsets, 0)
    for i := 0; i <= maxLevel; i++ {
        offsets = append(offsets, totalCount)
        totalCount = totalCount + layerCount
        layerCount = layerCount * 8
    }

    g_octrees[id.octree].offsets = offsets
    count = totalCount

    g_octrees[id.octree].visibles = resize(g_octrees[id.octree].visibles, 0)
}

// OctreeUpdate ...
func OctreeUpdate(id OctreeId, frustum FrustumId, targetLevel i32) {
    panicIfNot(OctreeIsValid(id), "invalid id")

    var totalCount i32 = resetOffsets(id)
    octreeUpdateLevel(id, 0, frustum, true, targetLevel)


    if IsValidMesh(g_octrees[id.octree].debugMesh) {
        MeshBegin(g_octrees[id.octree].debugMesh)
        var cells []OctreeCell = g_octrees[id.octree].cells
        var visibles []i32 = g_octrees[id.octree].visibles
        var visibleCount i32 = len(visibles)
        for i := 0; i < visibleCount; i++ {
            var offset i32 = visibles[i]
            var center mat.v3 = cells[offset].center
            var size mat.v3 = v3.mulf(cells[offset].size, 0.99)
            MeshAppendBox(g_octrees[id.octree].debugMesh, true, false,
                center, v3.make(size.x, 0.0, 0.0), v3.make(0.0, size.y, 0.0), v3.make(0.0, 0.0, size.z), v4.RED)
        }
    /*
    var min mat.v3
    var max mat.v3
    var mins []mat.v3 = g_octrees[id.octree].mins
    var maxs []mat.v3 = g_octrees[id.octree].maxs
    var primitiveCount i32 = len(mins)
    for i := 0; i < primitiveCount; i++ {
        var size mat.v3 = v3.mulf(v3.sub(maxs[i], mins[i]), 0.5)
        var center mat.v3 = v3.add(mins[i], size)
        MeshAppendBox(g_octrees[id.octree].debugMesh, true, false,
            center, v3.make(size.x, 0.0, 0.0), v3.make(0.0, size.y, 0.0), v3.make(0.0, 0.0, size.z),
            v4.PINK)
    }
    */
        MeshEnd(g_octrees[id.octree].debugMesh)
    }
}

/*var P0 fps.ProfileId = fps.InvalidProfile()
var P1 fps.ProfileId = fps.InvalidProfile()
var P2 fps.ProfileId = fps.InvalidProfile()
var P3 fps.ProfileId = fps.InvalidProfile()
var P4 fps.ProfileId = fps.InvalidProfile()
var P5 fps.ProfileId = fps.InvalidProfile()
var P6 fps.ProfileId = fps.InvalidProfile()*/


// OctreeRender ...
func OctreeRender(id OctreeId, world mat.m44, view mat.m44, projection mat.m44,
    envSpec TextureId, envDiff TextureId, brdf TextureId, cameraPosition v4, exposure f32) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    DisableBlending()
    DepthState(true, LESS, true)
    g_octrees[id.octree].opaqueBuckets = sortBuckets(id, g_octrees[id.octree].opaqueBuckets, true)
    octreeRender(id, world, view, projection, g_octrees[id.octree].opaqueBuckets,
        envSpec, envDiff, brdf, cameraPosition, exposure)

    EnableBlending(SRC_ALPHA, ONE_MINUS_SRC_ALPHA)
    DepthState(true, LESS, false)
    g_octrees[id.octree].transparentBuckets = sortBuckets(id, g_octrees[id.octree].transparentBuckets, false)
    octreeRender(id, world, view, projection, g_octrees[id.octree].transparentBuckets,
        envSpec, envDiff, brdf, cameraPosition, exposure)

    if IsValidMesh(g_octrees[id.octree].debugMesh) {
        DepthState(true, LESS, false)
	    EffectUse(g_fxVertexColor3D)
	    EffectAssignM44(g_fxVertexColor3D, UNIFORM_WORLD, world, false)
	    EffectAssignM44(g_fxVertexColor3D, UNIFORM_VIEW, view, false)
	    EffectAssignM44(g_fxVertexColor3D, UNIFORM_PROJECTION, projection, false)
	    MeshRender(g_octrees[id.octree].debugMesh)
    }
}

func sortBuckets(id OctreeId, in []PrimitiveBucket, opaque bool) (out []PrimitiveBucket) {
    out = in

    var cells []OctreeCell = g_octrees[id.octree].cells

    var visibles []i32 = g_octrees[id.octree].visibles
    var visibleCount i32 = len(visibles)

    var octreePrimitives []Primitive = g_octrees[id.octree].primitives

    var visiblePrimitives []i32 = g_octrees[id.octree].visiblePrimitives
    visiblePrimitives = resize(visiblePrimitives, 0)

    //P2 = fps.CreateStartProfile(P2, "OctreeRender : sort visibles")
    for visible := 0; visible < visibleCount; visible++ {
        var cellIndex i32 = visibles[visible]
        var cellPrimitives []i32
        if opaque {
            cellPrimitives = cells[cellIndex].opaques
        } else {
            cellPrimitives = cells[cellIndex].transparents
        }
        var primitiveCount i32 = len(cellPrimitives)
        for primitive := 0; primitive < primitiveCount; primitive++ {
            var octreePrimitiveIndex i32 = cellPrimitives[primitive]
            if octreePrimitiveIndex >= 0 {
                visiblePrimitives = append(visiblePrimitives, cellPrimitives[primitive])
            }
        }
    }

    out = PrimitiveSort1(octreePrimitives, visiblePrimitives, out)

    //fps.StopProfile(P2)
}

func octreeRender(id OctreeId, world mat.m44, view mat.m44, projection mat.m44, buckets []PrimitiveBucket,
    envSpec TextureId, envDiff TextureId, brdf TextureId, cameraPosition v4, exposure f32) {
    //P0 = fps.CreateStartProfile(P0, "OctreeRender")
    //P1 = fps.CreateStartProfile(P1, "P1")
    panicIfNot(OctreeIsValid(id), "invalid id")

    var lastEffect i32 = -1
    var lastBaseTexture i32 = -1
    var lastNormalTexture i32 = -1
    var lastMetalRoughTexture i32 = -1
    var lastEmissiveTexture i32 = -1
    var lastOcclusionTexture i32 = -1
    var lastBaseColorFactor mat.v4 = v4.makef(-1.0)
    var lastEmissiveFactor mat.v4 = v4.makef(-1.0)
    var lastMetalRoughFactor mat.v4 = v4.makef(-1.0)
    var lastTransform mat.m44 = m44.INVALID

    var octreePrimitives []Primitive = g_octrees[id.octree].primitives
    //fps.StopProfile(P1)
    //P3 = fps.CreateStartProfile(P3, "OctreeRender : render")
    var bucketCount i32 = len(buckets)
    for bucket := 0; bucket < bucketCount; bucket++ {
        var sortedPrimitives []i32 = buckets[bucket].primitives
        var sortedCount i32 = len(sortedPrimitives)
	    var effect EffectId = buckets[bucket].effect
        if lastEffect != effect.effect {
            lastEffect = effect.effect

            EffectUse(effect)
	        EffectTryAssignTexture(effect, SAMPLER_ENV_SPECULAR, envSpec, g_linearClamp)
            EffectTryAssignTexture(effect, SAMPLER_ENV_DIFFUSE, envDiff, g_linear0Clamp)
		    EffectTryAssignTexture(effect, SAMPLER_BRDF, brdf, g_linear0Clamp) // TODO : use gltf sampler

            EffectAssignM44(effect, UNIFORM_WORLD, world, false)
            EffectAssignM44(effect, UNIFORM_VIEW, view, false)
   	        EffectAssignM44(effect, UNIFORM_PROJECTION, projection, false)

            EffectAssignV4(effect, UNIFORM_CAMERA_POSITION, cameraPosition)
   	        EffectAssignV4(effect, UNIFORM_DEBUG_0, DEBUG_0)
            EffectAssignV4(effect, UNIFORM_PBR, v4.make(i32.f32(TextureGetMipmapCount(envSpec)), exposure, 0.0, 0.0))

            lastBaseTexture = -1
            lastNormalTexture = -1
            lastMetalRoughTexture = -1
            lastEmissiveTexture = -1
            lastOcclusionTexture = -1
            lastBaseColorFactor = v4.makef(-1.0)
            lastEmissiveFactor = v4.makef(-1.0)
            lastMetalRoughFactor = v4.makef(-1.0)
        }

        var baseTexture TextureId = buckets[bucket].baseTexture
        if lastBaseTexture != baseTexture.texture {
            lastBaseTexture = baseTexture.texture
	        EffectTryAssignTexture(effect, SAMPLER_COLOR_0, baseTexture, g_linearWrap)
        }

        var normalTexture TextureId = buckets[bucket].normalTexture
        if lastNormalTexture != normalTexture.texture {
            lastNormalTexture = normalTexture.texture
	        EffectTryAssignTexture(effect, SAMPLER_NORMAL, normalTexture, g_linearWrap)
        }

        var metalRoughTexture TextureId = buckets[bucket].metalRoughTexture
        if lastMetalRoughTexture != metalRoughTexture.texture {
            lastMetalRoughTexture = metalRoughTexture.texture
            EffectTryAssignTexture(effect, SAMPLER_METAL_ROUGH, metalRoughTexture, g_linearWrap)
        }

        var emissiveTexture TextureId = buckets[bucket].emissiveTexture
        if lastEmissiveTexture != emissiveTexture.texture {
            lastEmissiveTexture = emissiveTexture.texture
            EffectTryAssignTexture(effect, SAMPLER_EMISSIVE, emissiveTexture, g_linearWrap)
        }

        var occlusionTexture TextureId = buckets[bucket].occlusionTexture
        if lastOcclusionTexture != occlusionTexture.texture {
            lastOcclusionTexture = occlusionTexture.texture
	        EffectTryAssignTexture(effect, SAMPLER_OCCLUSION, occlusionTexture, g_linearWrap)
        }

        for sorted := 0; sorted < sortedCount; sorted++ {
            var primitiveIndex i32 = sortedPrimitives[sorted]
            var primitive Primitive = octreePrimitives[primitiveIndex]
            var mesh MeshId = primitive.mesh

	        var metallicRoughness gltf.MetallicRoughness = primitive.gltfMaterial.pbrMetallicRoughness
	        if EffectIsValidUniformLocation(effect, UNIFORM_COLOR) {
	        	var baseColorFactor mat.v4 = metallicRoughness.baseColorFactor
	        	baseColorFactor.w = baseColorFactor.w// * alpha

                if  baseColorFactor.x != lastBaseColorFactor.x ||
                    baseColorFactor.y != lastBaseColorFactor.y ||
                    baseColorFactor.z != lastBaseColorFactor.z ||
                    baseColorFactor.w != lastBaseColorFactor.w {
                    lastBaseColorFactor = baseColorFactor
	          		EffectAssignV4(effect, UNIFORM_COLOR, baseColorFactor)
                }
	        }

	        if EffectIsValidUniformLocation(effect, UNIFORM_METAL_ROUGH) {
	        	var metallicRoughnessFactor mat.v4
                metallicRoughnessFactor.x = primitive.gltfMaterial.normalTexture.scale
	        	metallicRoughnessFactor.y = metallicRoughness.roughnessFactor
	        	metallicRoughnessFactor.z = metallicRoughness.metallicFactor

                if  metallicRoughnessFactor.x != lastMetalRoughFactor.x ||
                    metallicRoughnessFactor.y != lastMetalRoughFactor.y ||
                    metallicRoughnessFactor.z != lastMetalRoughFactor.z ||
                    metallicRoughnessFactor.w != lastMetalRoughFactor.w {
                    lastMetalRoughFactor = metallicRoughnessFactor
  	        	    EffectAssignV4(effect, UNIFORM_METAL_ROUGH, metallicRoughnessFactor)
                }
	        }

	        if EffectIsValidUniformLocation(effect, UNIFORM_EMISSIVE) {
                var emissiveFactor mat.v4 = primitive.gltfMaterial.emissiveFactor
                if  emissiveFactor.x != lastEmissiveFactor.x ||
                    emissiveFactor.y != lastEmissiveFactor.y ||
                    emissiveFactor.z != lastEmissiveFactor.z ||
                    emissiveFactor.w != lastEmissiveFactor.w {
                    lastEmissiveFactor = emissiveFactor
    	          	EffectAssignV4(effect, UNIFORM_EMISSIVE, emissiveFactor)
                }
            }

            //fps.StopProfile(P4)
            //P5 = fps.CreateStartProfile(P5, "mesh_render")
            MeshSetCulling(mesh, gl.CCW, gl.BACK)
	        MeshRender(mesh)
            //fps.StopProfile(P5)
        }
    }
    //fps.StopProfile(P3)
    //fps.StopProfile(P0)
}

func addVertexV2(positionAttribute i32, attributeCount i32, channels []channelInfo, index i32, in []ui8, transform mat.m44, cellIndex i32, cells []OctreeCell) (out []ui8) {
    out = in
    var positions []f32 = cells[cellIndex].positions
    for c := 0; c < attributeCount; c++ {
       var dataType i32 = channels[c].dataType
       var dataLen i32 = channels[c].dataLen
       var count i32 = channels[c].count
       var offset i32 = index * count
       if dataType == gl.FLOAT {
       	var dataF32 []f32 = channels[c].dataF32
        if positionAttribute == c {
            panicIf(count != 3, "invalid position attribute")
            if count == 3 {
                var pos mat.v3 = v3.make(dataF32[offset], dataF32[offset +1], dataF32[offset+2])
                pos = v3.transform_point(pos, transform)
                out = gl.AppendF32(out, pos.x)
                out = gl.AppendF32(out, pos.y)
                out = gl.AppendF32(out, pos.z)
                positions = append(positions, pos.x)
                positions = append(positions, pos.y)
                positions = append(positions, pos.z)
            }
        } else {
       	    for i := 0; i < count; i++ {
       		    out = gl.AppendF32(out, dataF32[offset + i])
       	    }
        }
       } else if dataType == gl.UNSIGNED_SHORT {
       	var dataUI16 []ui16 = channels[c].dataUI16
       	for i := 0; i < count; i++ {
       		out = gl.AppendUI16(out, dataUI16[offset + i])
       	}
       } else if dataType == gl.UNSIGNED_INT {
       	var dataUI32 []ui32 = channels[c].dataUI32
       	for i := 0; i < count; i++ {
       		out = gl.AppendUI32(out, dataUI32[offset + i])
       	}
       } else {
       	panicIf(true, "unhandled dataType")
       }
   }
    cells[cellIndex].positions = positions
}
func addVertex(attributeCount i32, positionAttribute i32, channels []channelInfo, position mat.v3, index i32, in []ui8, cellIndex i32, cells []OctreeCell) (out []ui8) {
    out = in
    var positions []f32 = cells[cellIndex].positions
    for c := 0; c < attributeCount; c++ {
        if c == positionAttribute {
            out = gl.AppendF32(out, position.x)
            out = gl.AppendF32(out, position.y)
            out = gl.AppendF32(out, position.z)
            positions = append(positions, position.x)
            positions = append(positions, position.y)
            positions = append(positions, position.z)
        } else {
    	    var dataType i32 = channels[c].dataType
    	    var dataLen i32 = channels[c].dataLen
    	    var count i32 = channels[c].count
    	    var offset i32 = index * count
    	    if dataType == gl.FLOAT {
    	    	var dataF32 []f32 = channels[c].dataF32
    	    	for i := 0; i < count; i++ {
    	    		out = gl.AppendF32(out, dataF32[offset + i])
    	    	}
    	    } else if dataType == gl.UNSIGNED_SHORT {
    	    	var dataUI16 []ui16 = channels[c].dataUI16
    	    	for i := 0; i < count; i++ {
    	    		out = gl.AppendUI16(out, dataUI16[offset + i])
    	    	}
    	    } else if dataType == gl.UNSIGNED_INT {
    	    	var dataUI32 []ui32 = channels[c].dataUI32
    	    	for i := 0; i < count; i++ {
    	    		out = gl.AppendUI32(out, dataUI32[offset + i])
    	    	}
    	    } else {
    	    	panicIf(true, "unhandled dataType")
    	    }
        }
    }
    cells[cellIndex].positions = positions
}

func lerpVertex(attributeCount i32, positionAttribute i32, channels []channelInfo, posA mat.v3, iA i32, posB mat.v3, iB i32, time f32, in []ui8) (out []ui8) {
    out = in
    for c := 0; c < attributeCount; c++ {
        if c == positionAttribute {
            out = gl.AppendF32(out, v1.lerp(posA.x, posB.x, time))
            out = gl.AppendF32(out, v1.lerp(posA.y, posB.y, time))
            out = gl.AppendF32(out, v1.lerp(posA.z, posB.z, time))
        } else {
    	    var dataType i32 = channels[c].dataType
    	    var dataLen i32 = channels[c].dataLen
    	    var count i32 = channels[c].count
    	    var oA i32 = iA * count
            var oB i32 = iB * count
    	    if dataType == gl.FLOAT {
    	    	var dataF32 []f32 = channels[c].dataF32
    	    	for i := 0; i < count; i++ {
    	    		out = gl.AppendF32(out, v1.lerp(dataF32[oA + i], dataF32[oB + i], time))
    	    	}
    	    } else if dataType == gl.UNSIGNED_SHORT {
    	    	var dataUI16 []ui16 = channels[c].dataUI16
    	    	for i := 0; i < count; i++ {
    	    		out = gl.AppendUI16(out, dataUI16[oB + i])
    	    	}
    	    } else if dataType == gl.UNSIGNED_INT {
    	    	var dataUI32 []ui32 = channels[c].dataUI32
    	    	for i := 0; i < count; i++ {
    	    		out = gl.AppendUI32(out, dataUI32[oB + i])
    	    	}
    	    } else {
    	    	panicIf(true, "unhandled dataType")
    	    }
        }
    }

}

func getPrimitiveIndex(octreePrimitives []Primitive,  attributes []VertexAttribute, cellPrimitives []i32, parent Primitive) (out i32) {
    out = -1
    var primitiveCount i32 = len(cellPrimitives)
    var attributeCount i32 = len(attributes)

    for primitiveIndex := 0; primitiveIndex < primitiveCount; primitiveIndex++ {
        var octreePrimitiveIndex i32 = cellPrimitives[primitiveIndex]
        var primitive Primitive = octreePrimitives[octreePrimitiveIndex]
        var primitiveAttributes []VertexAttribute = primitive.attributes
        if attributeCount == len(primitiveAttributes) {
            var same bool = true
            for i := 0; i < attributeCount; i++ {
                if attributes[i].componentCount != primitiveAttributes[i].componentCount ||
                   attributes[i].componentType != primitiveAttributes[i].componentType ||
                   attributes[i].componentByteSize != primitiveAttributes[i].componentByteSize ||
                   attributes[i].componentOffset != primitiveAttributes[i].componentOffset ||
                   attributes[i].byteOffset != primitiveAttributes[i].byteOffset ||
                   attributes[i].binding != primitiveAttributes[i].binding {
                    same = false
                    i = attributeCount
                }
            }

            if same {
                if primitive.baseTexture.texture == parent.baseTexture.texture &&
                   primitive.metalRoughTexture.texture == parent.metalRoughTexture.texture &&
                   primitive.normalTexture.texture == parent.normalTexture.texture &&
                   primitive.emissiveTexture.texture == parent.emissiveTexture.texture &&
                   primitive.occlusionTexture.texture == parent.occlusionTexture.texture &&
                   v4.equ(primitive.gltfMaterial.pbrMetallicRoughness.baseColorFactor, parent.gltfMaterial.pbrMetallicRoughness.baseColorFactor) &&
                   primitive.gltfMaterial.pbrMetallicRoughness.metallicFactor == parent.gltfMaterial.pbrMetallicRoughness.metallicFactor &&
                   primitive.gltfMaterial.pbrMetallicRoughness.roughnessFactor == parent.gltfMaterial.pbrMetallicRoughness.roughnessFactor &&
                   v4.equ(primitive.gltfMaterial.emissiveFactor, parent.gltfMaterial.emissiveFactor) &&
                   primitive.gltfMaterial.alphaMode == parent.gltfMaterial.alphaMode &&
                   primitive.gltfMaterial.doubleSided == parent.gltfMaterial.doubleSided {

                    out = primitiveIndex
                    return
                }
            }
        }
    }
}

func channelLerpVertex(to []channelInfo, from []channelInfo, i0 i32, i1 i32, time f32, cellIndex i32, cells []OctreeCell, positionAttribute i32) (out []channelInfo) {
    out = to
    var attributeCount i32 = len(from)
    for c := 0; c < attributeCount; c++ {
        var dataType i32 = from[c].dataType
        var dataLen i32 = from[c].dataLen
        var count i32 = from[c].count
        out[c].count = count
        var offset0 i32 = i0 * count
        var offset1 i32 = i1 * count;
        if dataType == gl.FLOAT {
            var dataOut  []f32 = out[c].dataF32
        	var dataF32 []f32 = from[c].dataF32
        	for i := 0; i < count; i++ {
                var f0 f32 = dataF32[offset0+i]
                var f1 f32 = dataF32[offset1+i]
                var fl f32 = v1.lerpsat(f0, f1, time)

        		dataOut = append(dataOut, fl)
        	    //dataOut = append(dataOut, dataF32[offset0 + i])
            }
            out[c].dataF32 = dataOut
            out[c].dataLen = len(dataOut)
        } else if dataType == gl.UNSIGNED_SHORT {
            var dataOut []ui16 = to[c].dataUI16
        	var dataUI16 []ui16 = from[c].dataUI16
        	for i := 0; i < count; i++ {
        		dataOut = append(dataOut, dataUI16[offset0 + i])
        	}
            out[c].dataUI16 = dataOut
            out[c].dataLen = len(dataOut)
        } else if dataType == gl.UNSIGNED_INT {
            var dataOut []ui32 = to[c].dataUI32
        	var dataUI32 []ui32 = from[c].dataUI32
        	for i := 0; i < count; i++ {
        		dataOut = append(dataOut, dataUI32[offset0 + i])
        	}
            out[c].dataUI32 = dataOut
            out[c].dataLen = len(dataOut)
        } else {
        	panicIf(true, "unhandled dataType")
        }
    }
}

func channelResize(from []channelInfo) (out []channelInfo) {
    out = from
    var channelCount i32 = len(from)
    for i := 0; i < channelCount; i++ {
        out[i].dataLen = 0
        out[i].dataF32 = resize(out[i].dataF32, 0)
        out[i].dataUI16 = resize(out[i].dataUI16, 0)
        out[i].dataUI32 = resize(out[i].dataUI32, 0)
    }
}

func channelGetPosition(from []channelInfo, channelIndex i32, vertexIndex i32) (out mat.v3) {
    var count i32 = from[channelIndex].count
    var data []f32 = from[channelIndex].dataF32
    var offset i32 = vertexIndex * count
    out.x = data[offset]
    out.y = data[offset + 1]
    out.z = data[offset + 2]
}

func channelAppendVertex(to []channelInfo, from []channelInfo, index i32, cellIndex i32, cells []OctreeCell, positionAttribute i32) (out []channelInfo) {
    out = to
    var attributeCount i32 = len(from)

    for c := 0; c < attributeCount; c++ {
        var dataType i32 = from[c].dataType
        var dataLen i32 = from[c].dataLen
        var count i32 = from[c].count
        var offset i32 = index * count
        out[c].count = count
        if dataType == gl.FLOAT {
            var dataOut  []f32 = out[c].dataF32
        	var dataF32 []f32 = from[c].dataF32
        	for i := 0; i < count; i++ {
                var pf f32 = dataF32[offset + i]
        		dataOut = append(dataOut, pf)
        	}
            out[c].dataF32 = dataOut
            out[c].dataLen = len(dataOut)
        } else if dataType == gl.UNSIGNED_SHORT {
            var dataOut []ui16 = to[c].dataUI16
        	var dataUI16 []ui16 = from[c].dataUI16
        	for i := 0; i < count; i++ {
        		dataOut = append(dataOut, dataUI16[offset + i])
        	}
            out[c].dataUI16 = dataOut
            out[c].dataLen = len(dataOut)
        } else if dataType == gl.UNSIGNED_INT {
            var dataOut []ui32 = to[c].dataUI32
        	var dataUI32 []ui32 = from[c].dataUI32
        	for i := 0; i < count; i++ {
        		dataOut = append(dataOut, dataUI32[offset + i])
        	}
            out[c].dataUI32 = dataOut
            out[c].dataLen = len(dataOut)
        } else {
        	panicIf(true, "unhandled dataType")
        }
    }
}

func computeTriangleCount(primitives []Primitive, cellPrimitives []i32) (out i32) {
    var primitiveCount i32 = len(cellPrimitives)
    for i := 0; i < primitiveCount; i++ {
        var primitiveIndex i32= cellPrimitives[i]
        if primitiveIndex >= 0 && primitiveIndex < len(primitives) {
        var indices []ui8 = primitives[primitiveIndex].indices
        var indexByteStride i32 = primitives[primitiveIndex].indexByteStride
        out = out + len(indices) / (indexByteStride * 3)
    }
    }
}
                var realTriangleCount i32

func octreeSplitMeshes(id OctreeId, meshes []i32, asset AssetId, primitives []Primitive, transforms []m44, cells []OctreeCell, cellIndex i32, cellPrimitives []i32, options i32) (out []i32) {
    var cellMax mat.v3 = cells[cellIndex].max
    var cellMin mat.v3 = cells[cellIndex].min
    var cellPlanesNormals []mat.v3 = cells[cellIndex].planesNormal
    var cellPlanesOrigins []mat.v3 = cells[cellIndex].planesOrigin
    var cellPoints []mat.v3 = cells[cellIndex].points
    var vertPos []bool
    var meshCount i32 = len(meshes)
    var mode i32
    var cullFace i32
    var octreePrimitives []Primitive = g_octrees[id.octree].primitives
    var triangleVertices []mat.v3
    triangleVertices = append(triangleVertices, v3.ZERO)
    triangleVertices = append(triangleVertices, v3.ZERO)
    triangleVertices = append(triangleVertices, v3.ZERO)

    for meshIndex := 0; meshIndex < meshCount; meshIndex++ {
        var renderable i32 = meshes[meshIndex]
        var primitive Primitive = primitives[renderable]
        var transform mat.m44 = transforms[primitive.nodeIndex]
        var channels []channelInfo = g_meshes[primitive.mesh.mesh].channels
        mode = g_meshes[primitive.mesh.mesh].primitive
        cullFace = g_meshes[primitive.mesh.mesh].cullFace

        var attributes []VertexAttribute = g_meshes[primitive.mesh.mesh].attributes
        var attributeCount i32 = len(attributes)
        var primitiveIndex i32 = getPrimitiveIndex(octreePrimitives, attributes, cellPrimitives, primitive)
        if primitiveIndex == -1 {
            var cellPrimitive Primitive
            cellPrimitive.attributes = attributes
            cellPrimitive.mesh = InvalidMesh()
            cellPrimitive.min = v3.MAX
            cellPrimitive.max = v3.MIN
            cellPrimitive.baseTexture = primitive.baseTexture
            cellPrimitive.metalRoughTexture = primitive.metalRoughTexture
            cellPrimitive.normalTexture = primitive.normalTexture
            cellPrimitive.emissiveTexture = primitive.emissiveTexture
            cellPrimitive.occlusionTexture = primitive.occlusionTexture
            cellPrimitive.gltfMaterial = primitive.gltfMaterial
            cellPrimitive.gltfPrimitive = primitive.gltfPrimitive
            cellPrimitive.useSkin = primitive.useSkin
            cellPrimitive.effect = primitive.effect
            cellPrimitive.indexByteStride = g_meshes[primitive.mesh.mesh].indexByteStride
            cellPrimitive.vertexByteStride = g_meshes[primitive.mesh.mesh].vertexByteStride
            cellPrimitive.usePosition = g_meshes[primitive.mesh.mesh].usePosition
            cellPrimitive.useNormal   = g_meshes[primitive.mesh.mesh].useNormal
            cellPrimitive.useColor    = g_meshes[primitive.mesh.mesh].useColor
            cellPrimitive.useTexcoord = g_meshes[primitive.mesh.mesh].useTexcoord
            cellPrimitive.useTangent  = g_meshes[primitive.mesh.mesh].useTangent
            cellPrimitive.useWeight   = g_meshes[primitive.mesh.mesh].useWeight
            cellPrimitive.useJoint    = g_meshes[primitive.mesh.mesh].useJoint
            primitiveIndex = len(cellPrimitives)
            cellPrimitives = append(cellPrimitives, len(octreePrimitives))
            octreePrimitives = append(octreePrimitives, cellPrimitive)
        }

        var octreePrimitiveIndex i32 = cellPrimitives[primitiveIndex]

        // TODO : bake
        var positionAttribute i32 = -1
        for attributeIndex := 0; attributeIndex < attributeCount; attributeIndex++ {
            var binding i32 = attributes[attributeIndex].binding
            if binding == ATTRIBUTE_POSITION {
                positionAttribute = attributeIndex
            }
        }

        var vertices []ui8 = octreePrimitives[octreePrimitiveIndex].vertices
        var oldVertexCount i32 = len(vertices)

        var indices []ui8 = octreePrimitives[octreePrimitiveIndex].indices
        var oldIndexCount i32 = len(indices)

        var posMin mat.v3 = octreePrimitives[octreePrimitiveIndex].min
        var posMax mat.v3 = octreePrimitives[octreePrimitiveIndex].max

        panicIf(positionAttribute == -1, "invalid position attribute")
        var positionData []f32 = channels[positionAttribute].dataF32
        var positionComponentCount i32 = attributes[positionAttribute].componentCount
        var world mat.m44 = transforms[primitive.nodeIndex]
        var indicesAccessor gltf.Accessor = gltf.AssetGetAccessor(asset, primitive.gltfPrimitive.indices)
        var indicesType i32 = indicesAccessor.componentType
        if indicesAccessor.componentCount == 1 {
            if indicesAccessor.componentType == gl.UNSIGNED_SHORT {
                var data []ui16 = indicesAccessor.dataUI16
                var index ui16 = i32.ui16(len(indices) / 2)
                var indexCount i32 = len(data)
                panicIf((indexCount % 3) != 0, "invalid index count")
                var triangleCount i32 = indexCount / 3
                for triangle := 0; triangle < triangleCount; triangle++ {
                    var ui0 ui16 = data[triangle * 3 + 0]
                    var ui1 ui16 = data[triangle * 3 + 1]
                    var ui2 ui16 = data[triangle * 3 + 2]
                    var i0 i32 = ui16.i32(ui0)
                    var i1 i32 = ui16.i32(ui1)
                    var i2 i32 = ui16.i32(ui2)
                    var pi0 i32 = i0 * positionComponentCount
                    var pi1 i32 = i1 * positionComponentCount
                    var pi2 i32 = i2 * positionComponentCount
                    var p0 mat.v3 = v3.transform_point(
                        v3.make(positionData[pi0], positionData[pi0 + 1], positionData[pi0 + 2]), transform)
                    var p1 mat.v3 = v3.transform_point(
                        v3.make(positionData[pi1], positionData[pi1 + 1], positionData[pi1 + 2]), transform)
                    var p2 mat.v3 = v3.transform_point(
                        v3.make(positionData[pi2], positionData[pi2 + 1], positionData[pi2 + 2]), transform)

                    triangleVertices[0] = p0
                    triangleVertices[1] = p1
                    triangleVertices[2] = p2

                    var x0 f32 = p0.x
                    var y0 f32 = p0.y
                    var z0 f32 = p0.z
                    var x1 f32 = p1.x
                    var y1 f32 = p1.y
                    var z1 f32 = p1.z
                    var x2 f32 = p2.x
                    var y2 f32 = p2.y
                    var z2 f32 = p2.z
                    var add i32
                    if x0 >= cellMin.x && x0 <= cellMax.x &&
                       y0 >= cellMin.y && y0 <= cellMax.y &&
                       z0 >= cellMin.z && z0 <= cellMax.z {
                        posMin.x = f32.min(posMin.x, x0)
                        posMin.y = f32.min(posMin.y, y0)
                        posMin.z = f32.min(posMin.z, z0)
                        posMax.x = f32.max(posMax.x, x0)
                        posMax.y = f32.max(posMax.y, y0)
                        posMax.z = f32.max(posMax.z, z0)
                        add = add | 1
                    }
                    if x1 >= cellMin.x && x1 <= cellMax.x &&
                       y1 >= cellMin.y && y1 <= cellMax.y &&
                       z1 >= cellMin.z && z1 <= cellMax.z {
                        posMin.x = f32.min(posMin.x, x1)
                        posMin.y = f32.min(posMin.y, y1)
                        posMin.z = f32.min(posMin.z, z1)
                        posMax.x = f32.max(posMax.x, x1)
                        posMax.y = f32.max(posMax.y, y1)
                        posMax.z = f32.max(posMax.z, z1)
                        add = add | 2
                    }
                    if x2 >= cellMin.x && x2 <= cellMax.x &&
                       y2 >= cellMin.y && y2 <= cellMax.y &&
                       z2 >= cellMin.z && z2 <= cellMax.z {
                        posMin.x = f32.min(posMin.x, x2)
                        posMin.y = f32.min(posMin.y, y2)
                        posMin.z = f32.min(posMin.z, z2)
                        posMax.x = f32.max(posMax.x, x2)
                        posMax.y = f32.max(posMax.y, y2)
                        posMax.z = f32.max(posMax.z, z2)
                        add = add | 4
                    }

                    if add == 7 {
                        if cullFace == gl.BACK || cullFace == gl.NONE {
                            vertices = addVertex(attributeCount, positionAttribute, channels, p0, i0, vertices, cellIndex, cells)
                            vertices = addVertex(attributeCount, positionAttribute, channels, p1, i1, vertices, cellIndex, cells)
                            vertices = addVertex(attributeCount, positionAttribute, channels, p2, i2, vertices, cellIndex, cells)
                            indices = gl.AppendUI16(indices, index)
                            index = index + 1UH
                            indices = gl.AppendUI16(indices, index)
                            index = index + 1UH
                            indices = gl.AppendUI16(indices, index)
                            index = index + 1UH
                        }

                        if cullFace == gl.FRONT || cullFace == gl.NONE {
                            vertices = addVertex(attributeCount, positionAttribute, channels, p2, i2, vertices, cellIndex, cells)
                            vertices = addVertex(attributeCount, positionAttribute, channels, p1, i1, vertices, cellIndex, cells)
                            vertices = addVertex(attributeCount, positionAttribute, channels, p0, i0, vertices, cellIndex, cells)
                            indices = gl.AppendUI16(indices, index)
                            index = index + 1UH
                            indices = gl.AppendUI16(indices, index)
                            index = index + 1UH
                            indices = gl.AppendUI16(indices, index)
                            index = index + 1UH
                        }
                    } else {
                        if mat.TriangleIntersectsAABB(cellMin, cellMax, cellPoints, triangleVertices) {
                            var newChannels []channelInfo // TODO : remove alloc
                            var oldChannels []channelInfo // TODO : remove alloc
                            for a := 0; a < attributeCount; a++ {
                                var chan channelInfo
                                chan.count = channels[a].count
                                chan.dataType = channels[a].dataType
                                oldChannels = append(oldChannels, chan)
                                newChannels = append(newChannels, chan)
                            }

                            oldChannels = channelAppendVertex(oldChannels, channels, i0, cellIndex, cells, positionAttribute)
                            oldChannels = channelAppendVertex(oldChannels, channels, i1, cellIndex, cells, positionAttribute)
                            oldChannels = channelAppendVertex(oldChannels, channels, i2, cellIndex, cells, positionAttribute)

                            for p := 0; p < 6; p++ {
                                var upFront i32 = -1
                                var downFront i32 = -1
                                var planeNormal mat.v3 = cellPlanesNormals[p]
                                var planeOrigin mat.v3 = cellPlanesOrigins[p]
                                var step i32 = -1
                                var vertCount i32 = oldChannels[0].dataLen / oldChannels[0].count
                                vertPos = resize(vertPos, 0)
                                var belowCount i32
                                for v := 0; v < vertCount; v++ {
                                    var currentPos mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, v), transform)
                                    var pdp f32 = v3.dot(v3.sub(currentPos, planeOrigin), planeNormal)
                                    var pointBelowPlane bool
                                    if pdp < 0.0 {
                                        pointBelowPlane = true
                                        belowCount = belowCount + 1
                                    }
                                    vertPos = append(vertPos, pointBelowPlane)
                                }

                                for v := 0; v < vertCount; v++ {
                                    var nextPos i32 = (v+1)%vertCount
                                    if vertPos[v] == true && vertPos[nextPos] == false {
                                        upFront = v
                                    } else if vertPos[v] == false && vertPos[nextPos] == true {
                                        downFront = v
                                    }
                                }

                                newChannels = channelResize(newChannels)
                                if upFront >= 0 && downFront >= 0 {
                                    panicIf(upFront == downFront, "invalid fronts")
                                    var vup mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, upFront), transform)
                                    var upNext i32 = (upFront+1)%vertCount
                                    var vupNext mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, upNext), transform)
                                    var itup bool
                                    var tup f32
                                    itup, tup = mat.RayIntersectsPlane(vup, vupNext, planeOrigin, planeNormal)
                                    if itup {
                                        newChannels = channelLerpVertex(newChannels, oldChannels, upFront, upNext, tup, cellIndex, cells, positionAttribute)
                                    } else {
                                        newChannels = channelAppendVertex(newChannels, oldChannels, upFront, cellIndex, cells, positionAttribute)
                                        newChannels = channelAppendVertex(newChannels, oldChannels, upNext, cellIndex, cells, positionAttribute)
                                    }

                                    var vdown mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, downFront), transform)
                                    var downNext i32 = (downFront+1)%vertCount
                                    var vdownNext mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, downNext), transform)
                                    var itdown bool
                                    var tdown f32
                                    itdown, tdown = mat.RayIntersectsPlane(vdown, vdownNext, planeOrigin, planeNormal)
                                    if itdown {
                                        newChannels = channelLerpVertex(newChannels, oldChannels, downFront, downNext, tdown, cellIndex, cells, positionAttribute)
                                    } else {
                                        newChannels = channelAppendVertex(newChannels, oldChannels, downFront, cellIndex, cells, positionAttribute)
                                        newChannels = channelAppendVertex(newChannels, oldChannels, downNext, cellIndex, cells, positionAttribute)
                                    }

                                    var cfront bool = true
                                    var nv i32 = (downFront + 1) %vertCount
                                    for cfront == true {
                                        if nv == upFront {
                                            cfront = false
                                        } else {
                                            newChannels = channelAppendVertex(newChannels, oldChannels, nv, cellIndex, cells, positionAttribute)
                                            nv = (nv + 1) %vertCount
                                        }
                                    }
                                    newChannels = channelAppendVertex(newChannels, oldChannels, nv, cellIndex, cells, positionAttribute)
                                    var tmpChannels []channelInfo = oldChannels
                                    oldChannels = newChannels
                                    newChannels = tmpChannels
                                }
                            }

                            var vertexCount i32 = oldChannels[0].dataLen / oldChannels[0].count
                            for v := 0; v < vertexCount - 1; v++ {
                                triangleVertices[0] = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, 0), transform)
                                triangleVertices[1] = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, v), transform)
                                triangleVertices[2] = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, v + 1), transform)

                                if mat.TriangleIntersectsAABB(cellMin, cellMax, cellPoints, triangleVertices) {
                                    if cullFace == gl.BACK || cullFace == gl.NONE {
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, 0, vertices, transform, cellIndex, cells)
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, v, vertices, transform, cellIndex, cells)
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, v + 1, vertices, transform, cellIndex, cells)
                                        indices = gl.AppendUI16(indices, index)
                                        index = index + 1UH
                                        indices = gl.AppendUI16(indices, index)
                                        index = index + 1UH
                                        indices = gl.AppendUI16(indices, index)
                                        index = index + 1UH
                                    } 

                                    if cullFace == gl.FRONT || cullFace == gl.NONE {
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, v + 1, vertices, transform, cellIndex, cells)
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, v, vertices, transform, cellIndex, cells)
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, 0, vertices, transform, cellIndex, cells)
                                        indices = gl.AppendUI16(indices, index)
                                        index = index + 1UH
                                        indices = gl.AppendUI16(indices, index)
                                        index = index + 1UH
                                        indices = gl.AppendUI16(indices, index)
                                        index = index + 1UH
                                    }
                                } else {
                                }
                            }
                        }
                    }
                    octreePrimitives[octreePrimitiveIndex].indices = indices
                    octreePrimitives[octreePrimitiveIndex].vertices = vertices
                    octreePrimitives[octreePrimitiveIndex].min = posMin
                    octreePrimitives[octreePrimitiveIndex].max = posMax
                }
            } else if indicesAccessor.componentType == gl.UNSIGNED_INT {
                var data []ui32 = indicesAccessor.dataUI32
                var index ui32 = i32.ui32(len(indices) / 4)
                var indexCount i32 = len(data)
                panicIf((indexCount % 3) != 0, "invalid index count")
                var triangleCount i32 = indexCount / 3
                for triangle := 0; triangle < triangleCount; triangle++ {
                    var ui0 ui32 = data[triangle * 3 + 0]
                    var ui1 ui32 = data[triangle * 3 + 1]
                    var ui2 ui32 = data[triangle * 3 + 2]
                    var i0 i32 = ui32.i32(ui0)
                    var i1 i32 = ui32.i32(ui1)
                    var i2 i32 = ui32.i32(ui2)
                    
                    var pi0 i32 = i0 * positionComponentCount
                    var pi1 i32 = i1 * positionComponentCount
                    var pi2 i32 = i2 * positionComponentCount
                    var p0 mat.v3 = v3.transform_point(
                        v3.make(positionData[pi0], positionData[pi0 + 1], positionData[pi0 + 2]), transform)
                    var p1 mat.v3 = v3.transform_point(
                        v3.make(positionData[pi1], positionData[pi1 + 1], positionData[pi1 + 2]), transform)
                    var p2 mat.v3 = v3.transform_point(
                        v3.make(positionData[pi2], positionData[pi2 + 1], positionData[pi2 + 2]), transform)

                    triangleVertices[0] = p0
                    triangleVertices[1] = p1
                    triangleVertices[2] = p2

                    var x0 f32 = p0.x
                    var y0 f32 = p0.y
                    var z0 f32 = p0.z
                    var x1 f32 = p1.x
                    var y1 f32 = p1.y
                    var z1 f32 = p1.z
                    var x2 f32 = p2.x
                    var y2 f32 = p2.y
                    var z2 f32 = p2.z
                    var add i32
                    if x0 >= cellMin.x && x0 <= cellMax.x &&
                       y0 >= cellMin.y && y0 <= cellMax.y &&
                       z0 >= cellMin.z && z0 <= cellMax.z {
                        posMin.x = f32.min(posMin.x, x0)
                        posMin.y = f32.min(posMin.y, y0)
                        posMin.z = f32.min(posMin.z, z0)
                        posMax.x = f32.max(posMax.x, x0)
                        posMax.y = f32.max(posMax.y, y0)
                        posMax.z = f32.max(posMax.z, z0)
                        add = add | 1
                    }
                    if x1 >= cellMin.x && x1 <= cellMax.x &&
                       y1 >= cellMin.y && y1 <= cellMax.y &&
                       z1 >= cellMin.z && z1 <= cellMax.z {
                        posMin.x = f32.min(posMin.x, x1)
                        posMin.y = f32.min(posMin.y, y1)
                        posMin.z = f32.min(posMin.z, z1)
                        posMax.x = f32.max(posMax.x, x1)
                        posMax.y = f32.max(posMax.y, y1)
                        posMax.z = f32.max(posMax.z, z1)
                        add = add | 2
                    }
                    if x2 >= cellMin.x && x2 <= cellMax.x &&
                       y2 >= cellMin.y && y2 <= cellMax.y &&
                       z2 >= cellMin.z && z2 <= cellMax.z {
                        posMin.x = f32.min(posMin.x, x2)
                        posMin.y = f32.min(posMin.y, y2)
                        posMin.z = f32.min(posMin.z, z2)
                        posMax.x = f32.max(posMax.x, x2)
                        posMax.y = f32.max(posMax.y, y2)
                        posMax.z = f32.max(posMax.z, z2)
                        add = add | 4
                    }

                    if add == 7 {
                        if cullFace == gl.BACK || cullFace == gl.NONE {
                            //if realTriangleCount >= minTriangle && realTriangleCount <= maxTriangle {
                            vertices = addVertex(attributeCount, positionAttribute, channels, p0, i0, vertices, cellIndex, cells)
                            vertices = addVertex(attributeCount, positionAttribute, channels, p1, i1, vertices, cellIndex, cells)
                            vertices = addVertex(attributeCount, positionAttribute, channels, p2, i2, vertices, cellIndex, cells)
                            indices = gl.AppendUI32(indices, index)
                            index = index + 1U
                            indices = gl.AppendUI32(indices, index)
                            index = index + 1U
                            indices = gl.AppendUI32(indices, index)
                            index = index + 1U
                            //}
                            realTriangleCount = realTriangleCount + 1
                        }
                        if cullFace == gl.FRONT || cullFace == gl.NONE {
                            //if realTriangleCount >= minTriangle && realTriangleCount <= maxTriangle {
                            vertices = addVertex(attributeCount, positionAttribute, channels, p2, i2, vertices, cellIndex, cells)
                            vertices = addVertex(attributeCount, positionAttribute, channels, p1, i1, vertices, cellIndex, cells)
                            vertices = addVertex(attributeCount, positionAttribute, channels, p0, i0, vertices, cellIndex, cells)
                            indices = gl.AppendUI32(indices, index)
                            index = index + 1U
                            indices = gl.AppendUI32(indices, index)
                            index = index + 1U
                            indices = gl.AppendUI32(indices, index)
                            index = index + 1U
                            //}
                            realTriangleCount = realTriangleCount + 1
                        }
                    } else {
                        if mat.TriangleIntersectsAABB(cellMin, cellMax, cellPoints, triangleVertices) {
                            var newChannels []channelInfo // TODO : remove alloc
                            var oldChannels []channelInfo // TODO : remove alloc
                            for a := 0; a < attributeCount; a++ {
                                var chan channelInfo
                                chan.count = channels[a].count
                                chan.dataType = channels[a].dataType
                                oldChannels = append(oldChannels, chan)
                                newChannels = append(newChannels, chan)
                            }

                            oldChannels = channelAppendVertex(oldChannels, channels, i0, cellIndex, cells, positionAttribute)
                            oldChannels = channelAppendVertex(oldChannels, channels, i1, cellIndex, cells, positionAttribute)
                            oldChannels = channelAppendVertex(oldChannels, channels, i2, cellIndex, cells, positionAttribute)

                            for p := 0; p < 6; p++ {
                                var upFront i32 = -1
                                var downFront i32 = -1
                                var planeNormal mat.v3 = cellPlanesNormals[p]
                                var planeOrigin mat.v3 = cellPlanesOrigins[p]
                                var step i32 = -1
                                var vertCount i32 = oldChannels[0].dataLen / oldChannels[0].count
                                vertPos = resize(vertPos, 0)
                                var belowCount i32
                                for v := 0; v < vertCount; v++ {
                                    var currentPos mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, v), transform)
                                    var pdp f32 = v3.dot(v3.sub(currentPos, planeOrigin), planeNormal)
                                    var pointBelowPlane bool
                                    if pdp < 0.0 {
                                        pointBelowPlane = true
                                        belowCount = belowCount + 1
                                    }
                                    vertPos = append(vertPos, pointBelowPlane)
                                }

                                for v := 0; v < vertCount; v++ {
                                    var nextPos i32 = (v+1)%vertCount
                                    if vertPos[v] == true && vertPos[nextPos] == false {
                                        upFront = v
                                    } else if vertPos[v] == false && vertPos[nextPos] == true {
                                        downFront = v
                                    }
                                }

                                newChannels = channelResize(newChannels)
                                if upFront >= 0 && downFront >= 0 {
                                    panicIf(upFront == downFront, "invalid fronts")
                                    var vup mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, upFront), transform)
                                    var upNext i32 = (upFront+1)%vertCount
                                    var vupNext mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, upNext), transform)
                                    var itup bool
                                    var tup f32
                                    itup, tup = mat.RayIntersectsPlane(vup, vupNext, planeOrigin, planeNormal)
                                    if itup {
                                        newChannels = channelLerpVertex(newChannels, oldChannels, upFront, upNext, tup, cellIndex, cells, positionAttribute)
                                    } else {
                                        newChannels = channelAppendVertex(newChannels, oldChannels, upFront, cellIndex, cells, positionAttribute)
                                        newChannels = channelAppendVertex(newChannels, oldChannels, upNext, cellIndex, cells, positionAttribute)
                                    }

                                    var vdown mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, downFront), transform)
                                    var downNext i32 = (downFront+1)%vertCount
                                    var vdownNext mat.v3 = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, downNext), transform)
                                    var itdown bool
                                    var tdown f32
                                    itdown, tdown = mat.RayIntersectsPlane(vdown, vdownNext, planeOrigin, planeNormal)
                                    if itdown {
                                        newChannels = channelLerpVertex(newChannels, oldChannels, downFront, downNext, tdown, cellIndex, cells, positionAttribute)
                                    } else {
                                        newChannels = channelAppendVertex(newChannels, oldChannels, downFront, cellIndex, cells, positionAttribute)
                                        newChannels = channelAppendVertex(newChannels, oldChannels, downNext, cellIndex, cells, positionAttribute)
                                    }

                                    var cfront bool = true
                                    var nv i32 = (downFront + 1) %vertCount
                                    for cfront == true {
                                        if nv == upFront {
                                            cfront = false
                                        } else {
                                            newChannels = channelAppendVertex(newChannels, oldChannels, nv, cellIndex, cells, positionAttribute)
                                            nv = (nv + 1) %vertCount
                                        }
                                    }
                                    newChannels = channelAppendVertex(newChannels, oldChannels, nv, cellIndex, cells, positionAttribute)
                                    var tmpChannels []channelInfo = oldChannels
                                    oldChannels = newChannels
                                    newChannels = tmpChannels
                                }
                            }

                            var vertexCount i32 = oldChannels[0].dataLen / oldChannels[0].count
                            for v := 0; v < vertexCount - 1; v++ {
                                triangleVertices[0] = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, 0), transform)
                                triangleVertices[1] = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, v), transform)
                                triangleVertices[2] = v3.transform_point(channelGetPosition(oldChannels, positionAttribute, v + 1), transform)

                                if mat.TriangleIntersectsAABB(cellMin, cellMax, cellPoints, triangleVertices) {
                                    if cullFace == gl.BACK || cullFace == gl.NONE {
                                        //if realTriangleCount >= minTriangle && realTriangleCount <= maxTriangle {
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, 0, vertices, transform, cellIndex, cells)
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, v, vertices, transform, cellIndex, cells)
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, v + 1, vertices, transform, cellIndex, cells)
                                        indices = gl.AppendUI32(indices, index)
                                        index = index + 1U
                                        indices = gl.AppendUI32(indices, index)
                                        index = index + 1U
                                        indices = gl.AppendUI32(indices, index)
                                        index = index + 1U
                                        //}
                                        realTriangleCount = realTriangleCount + 1
                                    } 
                                    if cullFace == gl.FRONT || cullFace == gl.NONE {
                                        //if realTriangleCount >= minTriangle && realTriangleCount <= maxTriangle {
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, v + 1, vertices, transform, cellIndex, cells)
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, v, vertices, transform, cellIndex, cells)
                                        vertices = addVertexV2(positionAttribute, attributeCount, oldChannels, 0, vertices, transform, cellIndex, cells)
                                        indices = gl.AppendUI32(indices, index)
                                        index = index + 1U
                                        indices = gl.AppendUI32(indices, index)
                                        index = index + 1U
                                        indices = gl.AppendUI32(indices, index)
                                        index = index + 1U
                                        //}
                                        realTriangleCount = realTriangleCount + 1
                                    }
                                } else {
                                }
                            }
                        }
                    }
                    octreePrimitives[octreePrimitiveIndex].indices = indices
                    octreePrimitives[octreePrimitiveIndex].vertices = vertices
                    octreePrimitives[octreePrimitiveIndex].min = posMin
                    octreePrimitives[octreePrimitiveIndex].max = posMax
                }
            }
        }
        if len(indices) == oldIndexCount || len(vertices) == oldVertexCount {
            //printf("MESH NOT DISPATCHED IDX %d, %d, VTX %d, %d\n",
              //      oldIndexCount, len(indices), oldVertexCount, len(vertices))
        }
    }

    g_octrees[id.octree].primitives = octreePrimitives

    if options == OCTREE_GRAPHICS {
        var primitiveCount i32 = len(cellPrimitives)
        for primitiveIndex := 0; primitiveIndex < primitiveCount; primitiveIndex++ {
            var octreePrimitiveIndex i32 = cellPrimitives[primitiveIndex]
            var cellPrimitive Primitive = octreePrimitives[octreePrimitiveIndex]
            if len(cellPrimitive.vertices) > 0 && len(cellPrimitive.indices) > 0 {
                var attributes []VertexAttribute = cellPrimitive.attributes
                var mesh MeshId = MeshCreate(mode, indicesType,
                    len(cellPrimitive.indices) / cellPrimitive.indexByteStride,
                    attributes, len(cellPrimitive.vertices) / cellPrimitive.vertexByteStride)

                MeshBegin(mesh)
                g_meshes[mesh.mesh].vertices = cellPrimitive.vertices
                g_meshes[mesh.mesh].indices = cellPrimitive.indices
                g_meshes[mesh.mesh].usePosition = cellPrimitive.usePosition
                g_meshes[mesh.mesh].useNormal = cellPrimitive.useNormal
                g_meshes[mesh.mesh].useColor = cellPrimitive.useColor
                g_meshes[mesh.mesh].useTexcoord = cellPrimitive.useTexcoord
                g_meshes[mesh.mesh].useTangent = cellPrimitive.useTangent
                g_meshes[mesh.mesh].useWeight = cellPrimitive.useWeight
                g_meshes[mesh.mesh].useJoint = cellPrimitive.useJoint
                g_meshes[mesh.mesh].min = cellPrimitive.min
                g_meshes[mesh.mesh].max = cellPrimitive.max
                MeshEnd(mesh)


                octreePrimitives[octreePrimitiveIndex].mesh = mesh
            } else {
                //printf("Empty primitive... looks doubious\n")
                    cellPrimitives[primitiveIndex] = -1
            }
        }
    }
    out = cellPrimitives
}



func cellDispatchPrimitives(id OctreeId, level i32, cellMin mat.v3, cellMax mat.v3, parents []i32, children []i32) (out []i32) {
   
    out = children
    var mins []mat.v3 = g_octrees[id.octree].mins
    var maxs []mat.v3 = g_octrees[id.octree].maxs
    var parentCount i32 = len(parents)

    for parentIndex := 0; parentIndex < parentCount; parentIndex++ {
        var primitiveIndex i32 = parents[parentIndex]
        var primMin mat.v3 = mins[primitiveIndex]
        var primMax mat.v3 = maxs[primitiveIndex]

        if  primMin.x <= cellMax.x && primMax.x >= cellMin.x &&
            primMin.y <= cellMax.y && primMax.y >= cellMin.y &&
            primMin.z <= cellMax.z && primMax.z >= cellMin.z {
            out = append(out, primitiveIndex)
        }
    }
}



func octreeSplitModel(id OctreeId, model ModelId, level i32, opaques []i32, transparents []i32) {
    var maxLevel i32 = g_octrees[id.octree].maxLevel
    if level <= maxLevel {//&& ((len(opaques) > 0) || (len(transparents) > 0)) {
        var offset i32 = g_octrees[id.octree].offsets[level]
        g_octrees[id.octree].offsets[level] = offset + 1
        var cells []OctreeCell = g_octrees[id.octree].cells
        var cellMin mat.v3 = cells[offset].min
        var cellMax mat.v3 = cells[offset].max
        cells[offset].opaquePrimitives = cellDispatchPrimitives(
            id, level, cellMin, cellMax, opaques, cells[offset].opaquePrimitives)
        cells[offset].transparentPrimitives = cellDispatchPrimitives(
            id, level, cellMin, cellMax, transparents, cells[offset].transparentPrimitives)

        if level < maxLevel {
            var childLevel i32 = level + 1
            for i := 0; i < 8; i++ {
                octreeSplitModel(id, model, childLevel, cells[offset].opaquePrimitives, cells[offset].transparentPrimitives)
            }
        }
    }
}


func octreeUpdateCells(id OctreeId, level i32, center mat.v3, size mat.v3) (out i32) {
    out = -1
    var maxLevel i32 = g_octrees[id.octree].maxLevel
    if level <= maxLevel {
        var min mat.v3 = v3.sub(center, size)
        var max mat.v3 = v3.add(center, size)


        var offset i32 = g_octrees[id.octree].offsets[level]
        out = offset
        var cells []OctreeCell = g_octrees[id.octree].cells

        cells[offset].index = offset
        cells[offset].level = level
        cells[offset].center = center
        cells[offset].size = size
        cells[offset].min = min
        cells[offset].max = max

        var points []mat.v3
        var p0 mat.v3 = min
        var p1 mat.v3 = v3.make(max.x, min.y, min.z)
        var p2 mat.v3 = v3.make(min.x, max.y, min.z)
        var p3 mat.v3 = v3.make(max.x, max.y, min.z)
        var p4 mat.v3 = v3.make(min.x, min.y, max.z)
        var p5 mat.v3 = v3.make(max.x, min.y, max.z)
        var p6 mat.v3 = v3.make(min.x, max.y, max.z)
        var p7 mat.v3 = v3.make(max.x, max.y, max.z)

        points = append(points, p0)
        points = append(points, p1)
        points = append(points, p2)
        points = append(points, p3)
        points = append(points, p4)
        points = append(points, p5)
        points = append(points, p6)
        points = append(points, p7)

        var origins []mat.v3
        var normals []mat.v3

        var p40 mat.v3 = v3.normalize(v3.sub(p4, p0))
        var p10 mat.v3 = v3.normalize(v3.sub(p1, p0))
        var p20 mat.v3 = v3.normalize(v3.sub(p2, p0))
        var p31 mat.v3 = v3.normalize(v3.sub(p3, p1))
        var p51 mat.v3 = v3.normalize(v3.sub(p5, p1))
        var p32 mat.v3 = v3.normalize(v3.sub(p3, p2))
        var p62 mat.v3 = v3.normalize(v3.sub(p6, p2))
        var p64 mat.v3 = v3.normalize(v3.sub(p6, p4))
        var p54 mat.v3 = v3.normalize(v3.sub(p5, p4))

        normals = append(normals, v3.normalize(v3.cross(p40, p20)))
        normals = append(normals, v3.normalize(v3.cross(p31, p51)))
        normals = append(normals, v3.normalize(v3.cross(p10, p40)))
        normals = append(normals, v3.normalize(v3.cross(p62, p32)))
        normals = append(normals, v3.normalize(v3.cross(p20, p10)))
        normals = append(normals, v3.normalize(v3.cross(p54, p64)))

        origins = append(origins, p0)
        origins = append(origins, p1)
        origins = append(origins, p0)
        origins = append(origins, p2)
        origins = append(origins, p0)
        origins = append(origins, p4)

        cells[offset].planesNormal = normals
        cells[offset].planesOrigin = origins
        cells[offset].points = points

        g_octrees[id.octree].offsets[level] = offset + 1

        var childLevel i32 = level + 1
        var childSize mat.v3 = v3.mulf(size, 0.5)
        for i := 0; i < 8; i++ {
            cells[offset].children[i] = octreeUpdateCells(id, childLevel, v3.add(center, v3.mul(g_octreeCells[i], childSize)), childSize)
        }
    }
}

// OctreeIntersectsSphere ...
func OctreeIntersectsSphere(id OctreeId, position mat.v3, radius f32, in []i32) (out []i32) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    var totalCount i32 = resetOffsets(id)
    g_octrees[id.octree].tmp = in
    var inter i32 = octreeIntersectsSphere(id, position, radius, 0)
    out = g_octrees[id.octree].tmp

}

//OctreeGetCellOpaqueTriangleCount ...
func OctreeGetCellOpaqueTriangleCount(id OctreeId, cell i32) (out i32) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    out = g_octrees[id.octree].cells[cell].opaqueTriangleCount
}

//OctreeGetCellTransparentTriangleCount ...
func OctreeGetCellTransparentTriangleCount(id OctreeId, cell i32) (out i32) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    out = g_octrees[id.octree].cells[cell].transparentTriangleCount
}

//OctreeGetCellTriangleCount ...
func OctreeGetCellTriangleCount(id OctreeId, cell i32) (out i32) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    out = g_octrees[id.octree].cells[cell].triangleCount
}

// OctreeGetCellPositions ...
func OctreeGetCellPositions(id OctreeId, cell i32) (out []f32) {
    //panicIfNot(OctreeIsValid(id), "invalid id")
    out = g_octrees[id.octree].cells[cell].positions
}

// OctreeGetCellNormals ...
func OctreeGetCellNormals(id OctreeId, cell i32) (out []f32) {
    out = g_octrees[id.octree].cells[cell].normals
}

// OctreeGetCellCenter ...
func OctreeGetCellCenter(id OctreeId, cell i32) (out mat.v3) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    out = g_octrees[id.octree].cells[cell].center
}

// OctreeGetCellMin ...
func OctreeGetCellMin(id OctreeId, cell i32) (out mat.v3) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    out = g_octrees[id.octree].cells[cell].min
}

// OctreeGetCellMax ...
func OctreeGetCellMax(id OctreeId, cell i32) (out mat.v3) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    out = g_octrees[id.octree].cells[cell].max
}

func octreeIntersectsSphere(id OctreeId, position mat.v3, radius f32, level i32) (inter i32) {
    var out []i32 = g_octrees[id.octree].tmp
    var maxLevel i32 = g_octrees[id.octree].maxLevel
    if level <= maxLevel {
        var offsets []i32 = g_octrees[id.octree].offsets
        var offset i32 = offsets[level]
        offsets[level] = offset + 1

        var cells []OctreeCell = g_octrees[id.octree].cells
        inter = mat.SphereIntersectsAABB(position, radius, cells[offset].min, cells[offset].max)
        var childLevel i32 = level + 1
        var recurse i32 = 8
        if inter <= 0 {
            if level == maxLevel {
                out = append(out, offset)
                var cells []OctreeCell = g_octrees[id.octree].cells
                if cells[offset].triangleCount > 0 {
                    g_octrees[id.octree].tmp = out
                }
            } else {
                recurse = 0
                for i := 0; i < 8; i++ {
                    var childInter i32
                    childInter = octreeIntersectsSphere(id, position, radius, childLevel)
                    if childInter == -1 {
                        recurse = 8 - i - 1
                        i = 8
                    }
                }
            }
        }
        if recurse > 0 {
            var layerCount i32 = recurse
            for i := childLevel; i <= maxLevel; i++ {
                offsets[i] = offsets[i] + layerCount
                layerCount = layerCount * 8
            }
        }
    }
}

func octreeUpdateLevel(id OctreeId, level i32, frustum FrustumId, debug bool, targetLevel i32) {
    var maxLevel i32 = g_octrees[id.octree].maxLevel
    targetLevel = i32.min(maxLevel, targetLevel)
    if level <= targetLevel {
        var offsets []i32 = g_octrees[id.octree].offsets
        var offset i32 = offsets[level]
        offsets[level] = offset + 1

        var cells  []OctreeCell = g_octrees[id.octree].cells

        var inter i32 = FrustumIntersectsAABB(frustum, cells[offset].min, cells[offset].max)

        var childLevel i32 = level + 1
        var recurse bool
        if inter == 0 {
            if level == targetLevel {
                g_octrees[id.octree].visibles = append(g_octrees[id.octree].visibles, offset)
            } else {
                recurse = true
                for i := 0; i < 8; i++ {
                    octreeUpdateLevel(id, childLevel, frustum, debug, targetLevel)
                }
            }
        } else if inter == -1 {
            g_octrees[id.octree].visibles = append(g_octrees[id.octree].visibles, offset)
        } else if inter == 1 {
        }

        if recurse == false {
            var layerCount i32 = 8
            for i := childLevel; i <= maxLevel; i++ {
                offsets[i] = offsets[i] + layerCount
                layerCount = layerCount * 8
            }
        }
    }
}



